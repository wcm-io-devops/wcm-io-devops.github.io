<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FileGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CONGA Generator</a> &gt; <a href="index.source.html" class="el_package">io.wcm.devops.conga.generator</a> &gt; <span class="el_source">FileGenerator.java</span></div><h1>FileGenerator.java</h1><pre class="source lang-java linenums">/*
 * #%L
 * wcm.io
 * %%
 * Copyright (C) 2015 wcm.io
 * %%
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package io.wcm.devops.conga.generator;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Stream;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;

import com.github.jknack.handlebars.Template;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import io.wcm.devops.conga.generator.plugins.fileheader.NoneFileHeader;
import io.wcm.devops.conga.generator.plugins.validator.NoneValidator;
import io.wcm.devops.conga.generator.spi.FileHeaderPlugin;
import io.wcm.devops.conga.generator.spi.FilePlugin;
import io.wcm.devops.conga.generator.spi.ImplicitApplyOptions;
import io.wcm.devops.conga.generator.spi.PostProcessorPlugin;
import io.wcm.devops.conga.generator.spi.ValidatorPlugin;
import io.wcm.devops.conga.generator.spi.context.FileContext;
import io.wcm.devops.conga.generator.spi.context.FileHeaderContext;
import io.wcm.devops.conga.generator.spi.context.PluginContextOptions;
import io.wcm.devops.conga.generator.spi.context.PostProcessorContext;
import io.wcm.devops.conga.generator.spi.context.ValidatorContext;
import io.wcm.devops.conga.generator.spi.export.context.GeneratedFileContext;
import io.wcm.devops.conga.generator.util.FileUtil;
import io.wcm.devops.conga.generator.util.LineEndingConverter;
import io.wcm.devops.conga.generator.util.PluginManager;
import io.wcm.devops.conga.generator.util.VariableMapResolver;
import io.wcm.devops.conga.model.role.RoleFile;
import io.wcm.devops.conga.model.util.MapExpander;
import io.wcm.devops.conga.model.util.MapMerger;

/**
 * Generates file for one environment.
 */
@SuppressWarnings(&quot;PMD.MoreThanOneLogger&quot;)
class FileGenerator {

  private final String environmentName;
  private final String roleName;
  private final List&lt;String&gt; roleVariantNames;
  private final String templateName;
  private final File nodeDir;
  private final File file;
  private final String url;
  private final String symlinkTarget;
  private final RoleFile roleFile;
  private final Map&lt;String, Object&gt; config;
  private final Template template;
  private final PluginManager pluginManager;
  private final UrlFileManager urlFileManager;
  private final Logger log;
  private final FileContext fileContext;
  private final FileHeaderContext fileHeaderContext;
  private final ValidatorContext validatorContext;
  private final PostProcessorContext postProcessorContext;
  private final boolean allowSymlinks;

  // if the creation of a symlink fails once, do not try it again (esp. e.g. on windows systems)
  private static boolean symlinkCreationFailed;

  static final String POSTPROCESSOR_KEY_FILE_HEADER = &quot;postProcessor.fileHeader&quot;;
  static final String POSTPROCESSOR_KEY_VALIDATORS = &quot;postProcessor.validators&quot;;

  //CHECKSTYLE:OFF
  FileGenerator(GeneratorOptions options, String environmentName,
      String roleName, List&lt;String&gt; roleVariantNames, String templateName,
      File nodeDir, File file, String url, String symlinkTarget,
      RoleFile roleFile, Map&lt;String, Object&gt; config, Template template,
      VariableMapResolver variableMapResolver, UrlFileManager urlFileManager, PluginContextOptions pluginContextOptions,
<span class="fc" id="L106">      Collection&lt;String&gt; dependencyVersions) {</span>
    //CHECKSTYLE:ON
<span class="fc" id="L108">    this.environmentName = environmentName;</span>
<span class="fc" id="L109">    this.roleName = roleName;</span>
<span class="fc" id="L110">    this.roleVariantNames = roleVariantNames;</span>
<span class="fc" id="L111">    this.templateName = templateName;</span>
<span class="fc" id="L112">    this.nodeDir = nodeDir;</span>
<span class="fc" id="L113">    this.file = file;</span>
<span class="fc" id="L114">    this.url = url;</span>
<span class="fc" id="L115">    this.symlinkTarget = symlinkTarget;</span>
<span class="fc" id="L116">    this.roleFile = roleFile;</span>
<span class="fc" id="L117">    this.template = template;</span>
<span class="fc" id="L118">    this.pluginManager = options.getPluginManager();</span>
<span class="fc" id="L119">    this.urlFileManager = urlFileManager;</span>
<span class="fc" id="L120">    this.log = options.getLogger();</span>
<span class="fc" id="L121">    this.fileContext = new FileContext()</span>
<span class="fc" id="L122">        .file(file)</span>
<span class="fc" id="L123">        .charset(roleFile.getCharset())</span>
<span class="fc" id="L124">        .modelOptions(roleFile.getModelOptions())</span>
<span class="fc" id="L125">        .targetDir(nodeDir);</span>

    // overlay logger in options with plugin-specific logger
<span class="fc" id="L128">    Logger pluginLogger = new MessagePrefixLoggerFacade(log, &quot;    &quot;);</span>
<span class="fc" id="L129">    PluginContextOptions pluginContextOptionsForPlugin = new PluginContextOptions()</span>
<span class="fc" id="L130">        .pluginContextOptions(pluginContextOptions)</span>
<span class="fc" id="L131">        .logger(pluginLogger);</span>


<span class="fc" id="L134">    this.fileHeaderContext = new FileHeaderContext()</span>
<span class="fc" id="L135">        .pluginContextOptions(pluginContextOptionsForPlugin)</span>
<span class="fc" id="L136">        .commentLines(buildFileHeaderCommentLines(options.getVersion(), dependencyVersions));</span>

<span class="fc" id="L138">    this.validatorContext = new ValidatorContext()</span>
<span class="fc" id="L139">        .pluginContextOptions(pluginContextOptionsForPlugin)</span>
<span class="fc" id="L140">        .options(variableMapResolver.resolve(MapMerger.merge(roleFile.getValidatorOptions(), config)));</span>

<span class="fc" id="L142">    this.postProcessorContext = new PostProcessorContext()</span>
<span class="fc" id="L143">        .pluginContextOptions(pluginContextOptionsForPlugin)</span>
<span class="fc" id="L144">        .options(variableMapResolver.resolve(MapMerger.merge(roleFile.getPostProcessorOptions(), config)));</span>

<span class="fc" id="L146">    this.config = variableMapResolver.deescape(config);</span>
<span class="fc" id="L147">    this.allowSymlinks = options.isAllowSymlinks();</span>
<span class="fc" id="L148">  }</span>

  /**
   * Generate comment lines for file header added to all files for which a {@link FileHeaderPlugin} is registered.
   * @param dependencyVersions List of artifact versions to include
   * @return Formatted comment lines
   */
  private List&lt;String&gt; buildFileHeaderCommentLines(String version, Collection&lt;String&gt; dependencyVersions) {
<span class="fc" id="L156">    List&lt;String&gt; lines = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L158">    lines.add(&quot;This file is AUTO-GENERATED by CONGA. Please do not change it manually.&quot;);</span>
<span class="fc" id="L159">    lines.add(&quot;&quot;);</span>
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">    if (version != null) {</span>
<span class="fc" id="L161">      lines.add(&quot;Version &quot; + version);</span>
    }

    // add information how this file was generated
<span class="fc" id="L165">    lines.add(&quot;Environment: &quot; + environmentName);</span>
<span class="fc" id="L166">    lines.add(&quot;Role: &quot; + roleName);</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">    if (!roleVariantNames.isEmpty()) {</span>
<span class="fc" id="L168">      lines.add(&quot;Variant: &quot; + StringUtils.join(roleVariantNames, &quot;,&quot;));</span>
    }
<span class="fc" id="L170">    lines.add(&quot;Template: &quot; + templateName);</span>

<span class="pc bpc" id="L172" title="1 of 4 branches missed.">    if (dependencyVersions != null &amp;&amp; !dependencyVersions.isEmpty()) {</span>
<span class="fc" id="L173">      lines.add(&quot;&quot;);</span>
<span class="fc" id="L174">      lines.add(&quot;Dependencies:&quot;);</span>
<span class="fc" id="L175">      lines.addAll(dependencyVersions);</span>
    }

<span class="fc" id="L178">    return formatFileHeaderCommentLines(lines);</span>
  }

  /**
   * Format comment lines.
   * @param lines Unformatted comment lines
   * @return Formatted comment lines
   */
  private List&lt;String&gt; formatFileHeaderCommentLines(List&lt;String&gt; lines) {
<span class="fc" id="L187">    List&lt;String&gt; formattedLines = new ArrayList&lt;&gt;();</span>

    // create separator with same length as longest comment entry
<span class="fc" id="L190">    int maxLength = lines.stream()</span>
<span class="fc" id="L191">        .map(String::length)</span>
<span class="fc" id="L192">        .max(Integer::compare).orElse(0);</span>
<span class="fc" id="L193">    String separator = StringUtils.repeat(&quot;*&quot;, maxLength + 4);</span>

<span class="fc" id="L195">    formattedLines.add(separator);</span>
<span class="fc" id="L196">    formattedLines.add(&quot;&quot;);</span>
<span class="fc" id="L197">    lines.forEach(line -&gt; formattedLines.add(&quot;  &quot; + line));</span>
<span class="fc" id="L198">    formattedLines.add(&quot;&quot;);</span>
<span class="fc" id="L199">    formattedLines.add(separator);</span>

<span class="fc" id="L201">    return formattedLines;</span>
  }

  /**
   * Generate file(s).
   * @return List of files that where generated directly or indirectly (by post processors).
   */
  @SuppressFBWarnings({ &quot;ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD&quot;, &quot;RV_RETURN_VALUE_IGNORED_BAD_PRACTICE&quot; })
  public Collection&lt;GeneratedFileContext&gt; generate() throws IOException {
<span class="fc" id="L210">    File dir = file.getParentFile();</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">    if (!dir.exists()) {</span>
<span class="fc" id="L212">      dir.mkdirs();</span>
    }

    Collection&lt;GeneratedFileContext&gt; postProcessedFiles;
<span class="fc bfc" id="L216" title="All 2 branches covered.">    if (template != null) {</span>
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">      if (log.isInfoEnabled()) {</span>
<span class="fc" id="L218">        log.info(&quot;Generate file {}&quot;, getFilenameForLog(fileContext));</span>
      }

      // generate with template
<span class="fc" id="L222">      generateWithTemplate();</span>

      // add file header, validate and post-process generated file
<span class="fc" id="L225">      applyFileHeader(fileContext, roleFile.getFileHeader());</span>
<span class="fc" id="L226">      applyValidation(fileContext, roleFile.getValidators());</span>
<span class="fc" id="L227">      postProcessedFiles = applyPostProcessor(fileContext);</span>

    }
<span class="fc bfc" id="L230" title="All 2 branches covered.">    else if (StringUtils.isNotBlank(url)) {</span>

      // if copying from a local file try to create a symlink instead of coyping it
<span class="fc" id="L233">      boolean symlinkCreated = false;</span>
<span class="pc bpc" id="L234" title="5 of 8 branches missed.">      if (allowSymlinks &amp;&amp; !symlinkCreationFailed &amp;&amp; urlFileManager.isLocalFile(url) &amp;&amp; !roleFile.isDeleteSource()) {</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">        if (log.isInfoEnabled()) {</span>
<span class="nc" id="L236">          log.info(&quot;Symlink file {} from {}&quot;, getFilenameForLog(fileContext), url);</span>
        }
<span class="nc bnc" id="L238" title="All 2 branches missed.">        if (createSymlinkToLocalFile()) {</span>
<span class="nc" id="L239">          symlinkCreated = true;</span>
        }
        else {
<span class="nc" id="L242">          symlinkCreationFailed = true;</span>
        }
      }

      // generate by downloading/copying from URL
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">      if (!symlinkCreated) {</span>
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">        if (log.isInfoEnabled()) {</span>
<span class="fc" id="L249">          log.info(&quot;Copy file {} from {}&quot;, getFilenameForLog(fileContext), url);</span>
        }
<span class="fc" id="L251">        copyFromUrlFile();</span>
      }

      // post-process downloaded or symlinked file
<span class="fc" id="L255">      postProcessedFiles = applyPostProcessor(fileContext);</span>
<span class="fc" id="L256">    }</span>
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">    else if (StringUtils.isNotBlank(symlinkTarget)) {</span>

      // create a symlink pointing to the given target
<span class="fc" id="L260">      createSymlinkToSymlinkTarget();</span>

      // post-process symlinked file
<span class="fc" id="L263">      postProcessedFiles = applyPostProcessor(fileContext);</span>

    }
    else {
<span class="nc" id="L267">      throw new IOException(&quot;No template, URL or symlink target defined for file: &quot; + FileUtil.getFileInfo(roleName, roleFile));</span>
    }

<span class="fc" id="L270">    return postProcessedFiles;</span>
  }

  /**
   * Generate file with handlebars template.
   * Use unix file endings by default.
   */
  private void generateWithTemplate() throws IOException {
<span class="fc" id="L278">    try (FileOutputStream fos = new FileOutputStream(file);</span>
<span class="fc" id="L279">        Writer fileWriter = new OutputStreamWriter(fos, roleFile.getCharset())) {</span>
<span class="fc" id="L280">      StringWriter stringWriter = new StringWriter();</span>
<span class="fc" id="L281">      template.apply(config, stringWriter);</span>
<span class="fc" id="L282">      fileWriter.write(normalizeLineEndings(stringWriter.toString()));</span>
<span class="fc" id="L283">      fileWriter.flush();</span>
    }
<span class="fc" id="L285">  }</span>

  /**
   * Generate file by downloading/copying it's binary content from URL.
   */
  private void copyFromUrlFile() throws IOException {
<span class="fc" id="L291">    try (FileOutputStream fos = new FileOutputStream(file);</span>
<span class="fc" id="L292">        InputStream is = urlFileManager.getFile(url)) {</span>
<span class="fc" id="L293">      IOUtils.copy(is, fos);</span>
<span class="fc" id="L294">      fos.flush();</span>
    }
<span class="fc bfc" id="L296" title="All 2 branches covered.">    if (roleFile.isDeleteSource()) {</span>
<span class="fc" id="L297">      urlFileManager.deleteFile(url);</span>
    }
<span class="fc" id="L299">  }</span>

  /**
   * Create a symlink to a local file.
   * @return true if symlink creation was successful. This is likely to return false on windows operating systems.
   * @throws IOException If an unexpected error occurs
   */
  @SuppressWarnings(&quot;PMD.GuardLogStatement&quot;)
  private boolean createSymlinkToLocalFile() throws IOException {
    // if file is a local file try to create a symlink to it
<span class="nc" id="L309">    File localFile = urlFileManager.getLocalFile(url);</span>
<span class="nc" id="L310">    Path linkPath = file.toPath();</span>
<span class="nc" id="L311">    Path targetPath = localFile.toPath();</span>
    try {
<span class="nc" id="L313">      Files.createSymbolicLink(linkPath, targetPath);</span>
<span class="nc" id="L314">      return true;</span>
    }
<span class="nc" id="L316">    catch (IOException ex) {</span>
      // creates symbolic link failed - log warning and fallback to copying content
<span class="nc" id="L318">      log.warn(&quot;Unable to create symbolic link: {}&quot;, ex.getMessage());</span>
<span class="nc" id="L319">      return false;</span>
    }
  }

  /**
   * Create a symlink to the given symlink target.
   * @throws IOException If an unexpected error occurs
   */
  @SuppressWarnings(&quot;PMD.GuardLogStatement&quot;)
  private void createSymlinkToSymlinkTarget() throws IOException {
<span class="fc" id="L329">    File localFile = new File(nodeDir, this.symlinkTarget);</span>
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">    if (!localFile.exists()) {</span>
<span class="nc" id="L331">      throw new IOException(&quot;Symlink target file not found: &quot; + FileUtil.getCanonicalPath(localFile));</span>
    }
<span class="fc" id="L333">    Path linkPath = file.toPath();</span>
<span class="fc" id="L334">    Path targetPath = localFile.toPath();</span>
<span class="fc" id="L335">    Path relativizedPath = file.getParentFile().toPath().relativize(targetPath);</span>
    try {
<span class="fc" id="L337">      Files.createSymbolicLink(linkPath, relativizedPath);</span>
    }
<span class="nc" id="L339">    catch (IOException ex) {</span>
      // creates symbolic link failed - create text file with link instead (similar to git)
<span class="nc" id="L341">      log.warn(&quot;Created link textfile instead of symbolic link: {}&quot;, ex.getMessage());</span>
<span class="nc" id="L342">      FileUtils.write(linkPath.toFile(), relativizedPath.toString(), StandardCharsets.UTF_8);</span>
<span class="fc" id="L343">    }</span>
<span class="fc" id="L344">  }</span>

  private String normalizeLineEndings(String value) {
    // convert/normalize all line endings to unix style
<span class="fc" id="L348">    String normalizedLineEndings = LineEndingConverter.normalizeToUnix(value);</span>
    // and then to the line-ending style as requested in the tempalte definition
<span class="fc" id="L350">    return LineEndingConverter.convertTo(normalizedLineEndings, roleFile.getLineEndings());</span>
  }

  /**
   * Collect all file plugins that are either configured explicitely, or apply implicitely, or should always apply.
   * @param pluginClass File plugin class
   * @param fileItem File item
   * @param contextObject File plugin context object
   * @param pluginNames List of configured plugin names
   * @return List of plugins that should apply
   * @param &lt;T&gt; Plugin context object type.
   * @param &lt;R&gt; Return type of the plugin apply method.
   * @param &lt;P&gt; Plugin class
   */
  private &lt;T, R, P extends FilePlugin&lt;T, R&gt;&gt; Stream&lt;P&gt; collectFilePlugins(Class&lt;P&gt; pluginClass, FileContext fileItem, T contextObject,
      List&lt;String&gt; pluginNames) {
    Stream&lt;P&gt; plugins;
<span class="fc bfc" id="L367" title="All 2 branches covered.">    if (pluginNames.isEmpty()) {</span>
      // auto-detect matching plugins if none are defined
<span class="fc" id="L369">      plugins = pluginManager.getAll(pluginClass).stream()</span>
<span class="fc" id="L370">          .filter(plugin -&gt; plugin.accepts(fileItem, contextObject))</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">          .filter(plugin -&gt; plugin.implicitApply(fileItem, contextObject) == ImplicitApplyOptions.WHEN_UNCONFIGURED);</span>
    }
    else {
      // otherwise apply selected plugins
<span class="fc" id="L375">      plugins = pluginNames.stream()</span>
<span class="fc" id="L376">          .map(name -&gt; pluginManager.get(name, pluginClass));</span>
    }
    // add plugins that should always apply
<span class="fc" id="L379">    return Stream.concat(plugins, pluginManager.getAll(pluginClass).stream()</span>
<span class="fc" id="L380">          .filter(plugin -&gt; plugin.accepts(fileItem, contextObject))</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">          .filter(plugin -&gt; plugin.implicitApply(fileItem, contextObject) == ImplicitApplyOptions.ALWAYS));</span>
  }

  private void applyFileHeader(FileContext fileItem, String pluginName) {
<span class="fc" id="L385">    List&lt;String&gt; pluginNames = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">    if (!StringUtils.isEmpty(pluginName)) {</span>
<span class="fc" id="L387">      pluginNames.add(pluginName);</span>
    }
<span class="fc" id="L389">    collectFilePlugins(FileHeaderPlugin.class, fileItem, fileHeaderContext, pluginNames)</span>
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">        .filter(plugin -&gt; !StringUtils.equals(plugin.getName(), NoneFileHeader.NAME))</span>
<span class="fc" id="L391">        .forEach(plugin -&gt; applyFileHeader(fileItem, plugin));</span>
<span class="fc" id="L392">  }</span>

  private void applyFileHeader(FileContext fileItem, FileHeaderPlugin plugin) {
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">    if (log.isDebugEnabled()) {</span>
<span class="nc" id="L396">      log.debug(&quot;  Add {} file header to file {}&quot;, plugin.getName(), getFilenameForLog(fileItem));</span>
    }
<span class="fc" id="L398">    plugin.apply(fileItem, fileHeaderContext);</span>
<span class="fc" id="L399">  }</span>

  private void applyValidation(FileContext fileItem, List&lt;String&gt; pluginNames) {
<span class="fc" id="L402">    collectFilePlugins(ValidatorPlugin.class, fileItem, validatorContext, pluginNames)</span>
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">        .filter(plugin -&gt; !StringUtils.equals(plugin.getName(), NoneValidator.NAME))</span>
<span class="fc" id="L404">        .forEach(plugin -&gt; applyValidation(fileItem, plugin));</span>
<span class="fc" id="L405">  }</span>

  private void applyValidation(FileContext fileItem, ValidatorPlugin plugin) {
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">    if (log.isInfoEnabled()) {</span>
<span class="fc" id="L409">      log.info(&quot;  Validate {} for file {}&quot;, plugin.getName(), getFilenameForLog(fileItem));</span>
    }
<span class="fc" id="L411">    plugin.apply(fileItem, validatorContext);</span>
<span class="fc" id="L412">  }</span>

  private Collection&lt;GeneratedFileContext&gt; applyPostProcessor(FileContext fileItem) {
    // collect distinct list of files returned by each post processor
    // if a file is returned by multiple post processors combine to single entry with multiple plugin names
<span class="fc" id="L417">    Map&lt;String, GeneratedFileContext&gt; consolidatedFiles = new LinkedHashMap&lt;&gt;();</span>

    // start with original file
<span class="fc" id="L420">    consolidatedFiles.put(fileContext.getCanonicalPath(), new GeneratedFileContext().fileContext(fileContext));</span>

    // collect postprocessor plugins
<span class="fc" id="L423">    Stream&lt;PostProcessorPlugin&gt; postProcessors = collectFilePlugins(PostProcessorPlugin.class, fileItem, postProcessorContext,</span>
<span class="fc" id="L424">        roleFile.getPostProcessors());</span>

    // process all processors. if multiple processors each processor processed the files of the previous one.
<span class="fc" id="L427">    postProcessors.forEach(plugin -&gt; applyPostProcessor(consolidatedFiles, plugin));</span>

<span class="fc" id="L429">    return consolidatedFiles.values();</span>
  }

  private void applyPostProcessor(Map&lt;String, GeneratedFileContext&gt; consolidatedFiles, PostProcessorPlugin plugin) {

    // process all files from given map
<span class="fc" id="L435">    List.copyOf(consolidatedFiles.values()).stream()</span>
        // do not apply post processor twice
<span class="fc bfc" id="L437" title="All 2 branches covered.">        .filter(fileItem -&gt; !fileItem.getPostProcessors().contains(plugin.getName()))</span>
<span class="fc" id="L438">        .filter(fileItem -&gt; plugin.accepts(fileItem.getFileContext(), postProcessorContext))</span>
<span class="fc" id="L439">        .forEach(fileItem -&gt; {</span>
<span class="fc" id="L440">          List&lt;FileContext&gt; processedFiles = applyPostProcessor(fileItem.getFileContext(), plugin);</span>
<span class="fc" id="L441">          fileItem.postProcessor(plugin.getName());</span>
<span class="fc" id="L442">          processedFiles.forEach(item -&gt; {</span>
<span class="fc" id="L443">            GeneratedFileContext generatedFileContext = consolidatedFiles.get(item.getCanonicalPath());</span>
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">            if (generatedFileContext == null) {</span>
<span class="fc" id="L445">              generatedFileContext = new GeneratedFileContext().fileContext(item);</span>
<span class="fc" id="L446">              consolidatedFiles.put(item.getCanonicalPath(), generatedFileContext);</span>
            }
<span class="fc" id="L448">            generatedFileContext.postProcessor(plugin.getName());</span>
<span class="fc" id="L449">          });</span>
<span class="fc" id="L450">      });</span>

    // remove items that do no longer exist
<span class="fc" id="L453">    List.copyOf(consolidatedFiles.values()).forEach(fileItem -&gt; {</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">      if (!fileItem.getFileContext().getFile().exists()) {</span>
<span class="fc" id="L455">        consolidatedFiles.remove(fileItem.getFileContext().getCanonicalPath());</span>
      }
<span class="fc" id="L457">    });</span>

    // apply post processor configured as implicit ALWAYS
<span class="fc" id="L460">    consolidatedFiles.values().forEach(fileItem -&gt;</span>
<span class="fc" id="L461">      pluginManager.getAll(PostProcessorPlugin.class).stream()</span>
<span class="fc" id="L462">          .filter(implicitPlugin -&gt; implicitPlugin.accepts(fileItem.getFileContext(), postProcessorContext))</span>
<span class="fc bfc" id="L463" title="All 2 branches covered.">          .filter(implicitPlugin -&gt; implicitPlugin.implicitApply(fileItem.getFileContext(), postProcessorContext) == ImplicitApplyOptions.ALWAYS)</span>
          // do not apply post processor twice
<span class="fc bfc" id="L465" title="All 2 branches covered.">          .filter(implicitPlugin -&gt; !fileItem.getPostProcessors().contains(implicitPlugin.getName()))</span>
<span class="fc" id="L466">          .forEach(implicitPlugin -&gt; {</span>
<span class="fc" id="L467">            List&lt;FileContext&gt; processedFiles = applyPostProcessor(fileItem.getFileContext(), implicitPlugin);</span>
<span class="fc" id="L468">            fileItem.postProcessor(implicitPlugin.getName());</span>
<span class="fc" id="L469">            processedFiles.forEach(item -&gt; {</span>
<span class="nc" id="L470">              GeneratedFileContext generatedFileContext = consolidatedFiles.get(item.getCanonicalPath());</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">              if (generatedFileContext == null) {</span>
<span class="nc" id="L472">                generatedFileContext = new GeneratedFileContext().fileContext(item);</span>
<span class="nc" id="L473">                consolidatedFiles.put(item.getCanonicalPath(), generatedFileContext);</span>
              }
<span class="nc" id="L475">              generatedFileContext.postProcessor(implicitPlugin.getName());</span>
<span class="nc" id="L476">            });</span>
<span class="fc" id="L477">          })</span>
    );

    // remove items that do no longer exist
<span class="fc" id="L481">    List.copyOf(consolidatedFiles.values()).forEach(fileItem -&gt; {</span>
<span class="pc bpc" id="L482" title="1 of 2 branches missed.">      if (!fileItem.getFileContext().getFile().exists()) {</span>
<span class="nc" id="L483">        consolidatedFiles.remove(fileItem.getFileContext().getCanonicalPath());</span>
      }
<span class="fc" id="L485">    });</span>

<span class="fc" id="L487">  }</span>

  private List&lt;FileContext&gt; applyPostProcessor(FileContext fileItem, PostProcessorPlugin plugin) {
<span class="pc bpc" id="L490" title="1 of 2 branches missed.">    if (log.isInfoEnabled()) {</span>
<span class="fc" id="L491">      log.info(&quot;  Post-process {} for file {}&quot;, plugin.getName(), getFilenameForLog(fileItem));</span>
    }

<span class="fc" id="L494">    List&lt;FileContext&gt; processedFiles = plugin.apply(fileItem, postProcessorContext);</span>

<span class="pc bpc" id="L496" title="1 of 2 branches missed.">    if (processedFiles != null) {</span>
      // add file header, validate files
<span class="fc" id="L498">      processedFiles.forEach(processedFile -&gt; {</span>
<span class="fc" id="L499">        applyFileHeader(processedFile, getPostProcessorFileHeader());</span>
<span class="fc" id="L500">        applyValidation(processedFile, getPostProcessorValidators());</span>
<span class="fc" id="L501">      });</span>
    }

<span class="fc" id="L504">    return processedFiles;</span>
  }

  private String getPostProcessorFileHeader() {
<span class="fc" id="L508">    Object fileHeader = MapExpander.getDeep(postProcessorContext.getOptions(), POSTPROCESSOR_KEY_FILE_HEADER);</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">    if (fileHeader instanceof String) {</span>
<span class="fc" id="L510">      return (String)fileHeader;</span>
    }
    else {
<span class="fc" id="L513">      return null;</span>
    }
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  private List&lt;String&gt; getPostProcessorValidators() {
<span class="fc" id="L519">    Object validators = MapExpander.getDeep(postProcessorContext.getOptions(), POSTPROCESSOR_KEY_VALIDATORS);</span>
<span class="fc bfc" id="L520" title="All 2 branches covered.">    if (validators instanceof List) {</span>
<span class="fc" id="L521">      return (List&lt;String&gt;)validators;</span>
    }
    else {
<span class="fc" id="L524">      return List.of();</span>
    }
  }

  private String getFilenameForLog(FileContext fileItem) {
<span class="fc" id="L529">    return StringUtils.substring(fileItem.getCanonicalPath(), FileUtil.getCanonicalPath(nodeDir).length() + 1);</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>