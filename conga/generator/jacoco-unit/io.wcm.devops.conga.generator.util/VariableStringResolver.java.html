<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>VariableStringResolver.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CONGA Generator</a> &gt; <a href="index.source.html" class="el_package">io.wcm.devops.conga.generator.util</a> &gt; <span class="el_source">VariableStringResolver.java</span></div><h1>VariableStringResolver.java</h1><pre class="source lang-java linenums">/*
 * #%L
 * wcm.io
 * %%
 * Copyright (C) 2015 wcm.io
 * %%
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package io.wcm.devops.conga.generator.util;

import java.util.Map;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.Strings;

import io.wcm.devops.conga.generator.spi.context.ValueProviderGlobalContext;

/**
 * Resolve variables in a string referencing entries from a map.
 */
public final class VariableStringResolver {

  /*
   * variable pattern examples:
   * ${var1}
   * \${var1}
   * ${var1:defaultValue}
   * ${provider::var1}
   * ${provider::Var1:defaultValue}
   */
  @SuppressWarnings(&quot;java:S125&quot;) // no commented out code
  private static final String NAME_PATTERN_STRING = &quot;[^\\}\\{\\$\\:()'\&quot;/\\#,;\\+\\*@!\\^\\s]&quot;;
  private static final String NAME_PATTERN_STRING_NOT_EMPTY = NAME_PATTERN_STRING + &quot;+&quot;;
  private static final String NAME_PATTERN_STRING_OR_EMPTY = NAME_PATTERN_STRING + &quot;*&quot;;
  private static final String EXPRESSION_STRING = &quot;[^\\}\\{]+&quot;;

  static final int EXPRESSION_POS_DOLLAR_SIGN = 1;
  static final int EXPRESSION_POS_EXPRESSION = 2;

  private static final int VARIABLE_POS_VARIABLE_1 = 2;
  private static final int VARIABLE_POS_VALUE_PROVIDER_NAME = 4;
  private static final int VARIABLE_POS_VARIABLE_2 = 5;
  private static final int VARIABLE_POS_DEFAULT_VALUE = 7;

  private static final String EXPRESSION_PATTERN = &quot;(\\\\?\\$)&quot;
      + &quot;\\{(&quot; + EXPRESSION_STRING + &quot;)\\}&quot;;
<span class="fc" id="L61">  static final Pattern SINGLE_EXPRESSION_PATTERN = Pattern.compile(&quot;^&quot; + EXPRESSION_PATTERN + &quot;$&quot;);</span>
<span class="fc" id="L62">  static final Pattern MULTI_EXPRESSION_PATTERN = Pattern.compile(EXPRESSION_PATTERN);</span>
  private static final int REPLACEMENT_MAX_ITERATIONS = 20;

  /*
   * Either expect single strict variable name, or allow more complex expressions (e.g. jsonpath)
   * if a value provider plugin is referenced.
   */
<span class="fc" id="L69">  static final Pattern VARIABLE_PATTERN = Pattern.compile(&quot;((&quot; + NAME_PATTERN_STRING_NOT_EMPTY + &quot;)|&quot;</span>
      + &quot;((&quot; + NAME_PATTERN_STRING_NOT_EMPTY + &quot;)\\:\\:)&quot;
      + &quot;([^\\}\\{]*?))&quot;
      + &quot;(\\:(&quot; + NAME_PATTERN_STRING_OR_EMPTY + &quot;))?&quot;);

  private final VariableResolver variableResolver;
  private final JexlResolver jexlResolver;

  /**
   * Constructor.
   * @param valueProviderGlobalContext Value provider global context
   * @param variableMapResolver Variable map resolver
   */
  public VariableStringResolver(ValueProviderGlobalContext valueProviderGlobalContext,
<span class="fc" id="L83">      VariableMapResolver variableMapResolver) {</span>
<span class="fc" id="L84">    this.variableResolver = new VariableResolver(valueProviderGlobalContext);</span>
<span class="fc" id="L85">    this.jexlResolver = new JexlResolver(variableMapResolver);</span>
<span class="fc" id="L86">  }</span>

  /**
   * Replace variable placeholders in a string with syntax ${key} with values from a map.
   * The variables can recursively reference each other.
   * All escaped variables are deescaped.
   * @param value Value with variable placeholders
   * @param variables Variable map
   * @return Value with variable placeholders resolved.
   * @throws IllegalArgumentException when a variable name could not be resolve.d
   */
  public String resolveString(String value, Map&lt;String, Object&gt; variables) {
<span class="fc" id="L98">    Object result = resolve(value, variables);</span>
<span class="fc" id="L99">    return ValueUtil.valueToString(result);</span>
  }

  /**
   * Replace variable placeholders in a string with syntax ${key} with values from a map.
   * The variables can recursively reference each other.
   * All escaped variables are deescaped.
   * @param value Value with variable placeholders
   * @param variables Variable map
   * @return Value with variable placeholders resolved.
   * @throws IllegalArgumentException when a variable name could not be resolve.d
   */
  public Object resolve(String value, Map&lt;String, Object&gt; variables) {
<span class="fc" id="L112">    return resolve(value, variables, true);</span>
  }

  /**
   * Replace variable placeholders in a string with syntax ${key} with values from a map.
   * The variables can recursively reference each other.
   * @param value Value with variable placeholders
   * @param variables Variable map
   * @param deescapeVariables If true, {@link #deescape(String)} is applied to the result string
   * @return Value with variable placeholders resolved.
   * @throws IllegalArgumentException when a variable name could not be resolve.d
   */
  public String resolveString(String value, Map&lt;String, Object&gt; variables, boolean deescapeVariables) {
<span class="fc" id="L125">    Object result = resolve(value, variables, deescapeVariables);</span>
<span class="fc" id="L126">    return ValueUtil.valueToString(result);</span>
  }

  /**
   * Replace variable placeholders in a string with syntax ${key} with values from a map.
   * The variables can recursively reference each other.
   * @param value Value with variable placeholders
   * @param variables Variable map
   * @param deescapeVariables If true, {@link #deescape(String)} is applied to the result string
   * @return Value with variable placeholders resolved.
   * @throws IllegalArgumentException when a variable name could not be resolve.d
   */
  public Object resolve(String value, Map&lt;String, Object&gt; variables, boolean deescapeVariables) {
<span class="fc bfc" id="L139" title="All 2 branches covered.">    if (value == null) {</span>
<span class="fc" id="L140">      return null;</span>
    }

<span class="fc" id="L143">    Object result = resolve(value, variables, 0);</span>

<span class="fc bfc" id="L145" title="All 4 branches covered.">    if (deescapeVariables &amp;&amp; (result instanceof String stringValue)) {</span>
<span class="fc" id="L146">      result = deescape(stringValue);</span>
    }

<span class="fc" id="L149">    return result;</span>
  }

  /**
   * De-escapes all escaped variables in the given string.
   * @param value String that may contain escaped variable references (starting with \$)
   * @return String with de-escaped variable references.
   */
  public String deescape(String value) {
<span class="fc" id="L158">    return MULTI_EXPRESSION_PATTERN.matcher(value).replaceAll(&quot;\\$\\{&quot;</span>
        + &quot;$&quot; + EXPRESSION_POS_EXPRESSION + &quot;\\}&quot;);
  }

  private Object resolve(String value, Map&lt;String, Object&gt; variables, int iterationCount) {
<span class="fc bfc" id="L163" title="All 2 branches covered.">    if (iterationCount &gt;= REPLACEMENT_MAX_ITERATIONS) {</span>
<span class="fc" id="L164">      throw new IllegalArgumentException(&quot;Cyclic dependencies in variable string detected: &quot; + value);</span>
    }

    // check if variable string contains only single variable - in this case resolve and return value without necessarily converting it to a string
<span class="fc" id="L168">    Matcher matcherSingle = SINGLE_EXPRESSION_PATTERN.matcher(value);</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">    if (matcherSingle.matches()) {</span>
<span class="fc" id="L170">      return resolveSingle(matcherSingle, variables, iterationCount);</span>
    }
    else {
<span class="fc" id="L173">      Matcher matcherMulti = MULTI_EXPRESSION_PATTERN.matcher(value);</span>
<span class="fc" id="L174">      return resolveMulti(matcherMulti, variables, iterationCount);</span>
    }
  }

  @SuppressWarnings(&quot;java:S3776&quot;) // ignore complexity
  private Object resolveSingle(Matcher matcher, Map&lt;String, Object&gt; variables, int iterationCount) {
<span class="fc" id="L180">    boolean escapedVariable = Strings.CS.equals(matcher.group(EXPRESSION_POS_DOLLAR_SIGN), &quot;\\$&quot;);</span>
<span class="fc" id="L181">    String expression = matcher.group(EXPRESSION_POS_EXPRESSION);</span>

    // keep escaped variables intact
<span class="fc bfc" id="L184" title="All 2 branches covered.">    if (escapedVariable) {</span>
<span class="fc" id="L185">      return matcher.group(0);</span>
    }

    else {
<span class="fc" id="L189">      Matcher variableMatcher = VARIABLE_PATTERN.matcher(expression);</span>

      // resolve variable
<span class="fc bfc" id="L192" title="All 2 branches covered.">      if (variableMatcher.matches()) {</span>
<span class="fc" id="L193">        String valueProviderName = variableMatcher.group(VARIABLE_POS_VALUE_PROVIDER_NAME);</span>
<span class="fc" id="L194">        String variable = Objects.toString(variableMatcher.group(VARIABLE_POS_VARIABLE_1), variableMatcher.group(VARIABLE_POS_VARIABLE_2));</span>
<span class="fc" id="L195">        String defaultValueString = variableMatcher.group(VARIABLE_POS_DEFAULT_VALUE);</span>

<span class="fc" id="L197">        Object valueObject = variableResolver.resolve(valueProviderName, variable, defaultValueString, variables);</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">        if (valueObject != null) {</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">          if (valueObject instanceof String stringValue) {</span>
            // try again until all nested references are resolved
<span class="fc" id="L201">            return resolve(stringValue, variables, iterationCount + 1);</span>
          }
          else {
<span class="fc" id="L204">            return valueObject;</span>
          }
        }
        else {
<span class="fc" id="L208">          throw new IllegalArgumentException(&quot;Unable to resolve variable: &quot; + variable);</span>
        }
      }

      // resolve JEXL expression
      else {
<span class="fc" id="L214">        Object valueObject = jexlResolver.resolve(expression, variables);</span>
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">        if (valueObject != null) {</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">          if (valueObject instanceof String) {</span>
            // try again until all nested references are resolved
<span class="fc" id="L218">            return resolve((String)valueObject, variables, iterationCount + 1);</span>
          }
          else {
<span class="fc" id="L221">            return valueObject;</span>
          }
        }
        else {
<span class="nc" id="L225">          throw new IllegalArgumentException(&quot;Unable to resolve variable expression: &quot; + expression);</span>
        }
      }
    }
  }

  @SuppressWarnings(&quot;java:S3776&quot;) // ignore complexity
  private Object resolveMulti(Matcher matcher, Map&lt;String, Object&gt; variables, int iterationCount) {
<span class="fc" id="L233">    StringBuffer sb = new StringBuffer();</span>
<span class="fc" id="L234">    boolean replacedAny = false;</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">    while (matcher.find()) {</span>
<span class="fc" id="L236">      boolean escapedVariable = Strings.CS.equals(matcher.group(EXPRESSION_POS_DOLLAR_SIGN), &quot;\\$&quot;);</span>
<span class="fc" id="L237">      String expression = matcher.group(EXPRESSION_POS_EXPRESSION);</span>

      // keep escaped variables intact
<span class="fc bfc" id="L240" title="All 2 branches covered.">      if (escapedVariable) {</span>
<span class="fc" id="L241">        matcher.appendReplacement(sb, Matcher.quoteReplacement(matcher.group(0)));</span>
      }

      else {
<span class="fc" id="L245">        Matcher variableMatcher = VARIABLE_PATTERN.matcher(expression);</span>

        // resolve variable
<span class="fc bfc" id="L248" title="All 2 branches covered.">        if (variableMatcher.matches()) {</span>
<span class="fc" id="L249">          String valueProviderName = variableMatcher.group(VARIABLE_POS_VALUE_PROVIDER_NAME);</span>
<span class="fc" id="L250">          String variable = Objects.toString(variableMatcher.group(VARIABLE_POS_VARIABLE_1), variableMatcher.group(VARIABLE_POS_VARIABLE_2));</span>
<span class="fc" id="L251">          String defaultValueString = variableMatcher.group(VARIABLE_POS_DEFAULT_VALUE);</span>

<span class="fc" id="L253">          Object valueObject = variableResolver.resolve(valueProviderName, variable, defaultValueString, variables);</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">          if (valueObject != null) {</span>
<span class="fc" id="L255">            String variableValue = ValueUtil.valueToString(valueObject);</span>
<span class="fc" id="L256">            matcher.appendReplacement(sb, Matcher.quoteReplacement(variableValue));</span>
<span class="fc" id="L257">            replacedAny = true;</span>
<span class="fc" id="L258">          }</span>
          else {
<span class="fc" id="L260">            throw new IllegalArgumentException(&quot;Unable to resolve variable: &quot; + variable);</span>
          }
<span class="fc" id="L262">        }</span>

        // resolve JEXL expression
        else {
<span class="fc" id="L266">          Object valueObject = jexlResolver.resolve(expression, variables);</span>
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">          if (valueObject != null) {</span>
<span class="fc" id="L268">            String variableValue = ValueUtil.valueToString(valueObject);</span>
<span class="fc" id="L269">            matcher.appendReplacement(sb, Matcher.quoteReplacement(variableValue));</span>
<span class="fc" id="L270">            replacedAny = true;</span>
<span class="fc" id="L271">          }</span>
          else {
<span class="nc" id="L273">            throw new IllegalArgumentException(&quot;Unable to resolve variable expression: &quot; + expression);</span>
          }
        }
      }

<span class="fc" id="L278">    }</span>
<span class="fc" id="L279">    matcher.appendTail(sb);</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">    if (replacedAny) {</span>
      // try again until all nested references are resolved
<span class="fc" id="L282">      return resolve(sb.toString(), variables, iterationCount + 1);</span>
    }
    else {
<span class="fc" id="L285">      return sb.toString();</span>
    }
  }

  /**
   * Checks if the given string contains any reference to a variable from a value provider.
   * @param value Value string
   * @return true if a value provider reference was found.
   */
  public static boolean hasValueProviderReference(String value) {
<span class="fc" id="L295">    Matcher matcher = MULTI_EXPRESSION_PATTERN.matcher(value);</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">    while (matcher.find()) {</span>
<span class="fc" id="L297">      String expression = matcher.group(EXPRESSION_POS_EXPRESSION);</span>
<span class="fc" id="L298">      Matcher variableMatcher = VARIABLE_PATTERN.matcher(expression);</span>
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">      if (variableMatcher.matches()) {</span>
<span class="fc" id="L300">        String valueProviderName = variableMatcher.group(VARIABLE_POS_VALUE_PROVIDER_NAME);</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">        if (StringUtils.isNotEmpty(valueProviderName)) {</span>
<span class="fc" id="L302">          return true;</span>
        }
      }
<span class="fc" id="L305">    }</span>
<span class="fc" id="L306">    return false;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>