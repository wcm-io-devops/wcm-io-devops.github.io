<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>VariableMapResolver.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CONGA Generator</a> &gt; <a href="index.source.html" class="el_package">io.wcm.devops.conga.generator.util</a> &gt; <span class="el_source">VariableMapResolver.java</span></div><h1>VariableMapResolver.java</h1><pre class="source lang-java linenums">/*
 * #%L
 * wcm.io
 * %%
 * Copyright (C) 2015 wcm.io
 * %%
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package io.wcm.devops.conga.generator.util;

import static io.wcm.devops.conga.generator.util.VariableStringResolver.SINGLE_EXPRESSION_PATTERN;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;

import com.google.common.collect.ImmutableList;
import com.rits.cloning.Cloner;

import io.wcm.devops.conga.generator.spi.context.ValueProviderGlobalContext;

/**
 * Resolve variables in a map referencing other entries from the same map.
 */
public final class VariableMapResolver {

  /**
   * Special map property that references a list value to iterate on. For each list item a new item is created instead
   * of the map. The list items can be references with {@link #ITEM_VARIABLE}.
   */
  static final String LIST_VARIABLE_ITERATE = &quot;_iterate_&quot;;

  /**
   * Special variable name to reference item inside list generated by {@link #LIST_VARIABLE_ITERATE}.
   */
  static final String ITEM_VARIABLE = &quot;_item_&quot;;

  /**
   * Special variable name to reference item index inside list generated by {@link #LIST_VARIABLE_ITERATE}
   * (starting with 0).
   */
  static final String ITEM_INDEX_VARIABLE = &quot;_itemIndex_&quot;;

  private static final int REPLACEMENT_MAX_ITERATIONS = 20;

  private final VariableStringResolver variableStringResolver;

  /**
   * @param valueProviderGlobalContext Value provider global context
   */
<span class="fc" id="L65">  public VariableMapResolver(ValueProviderGlobalContext valueProviderGlobalContext) {</span>
<span class="fc" id="L66">    this.variableStringResolver = new VariableStringResolver(valueProviderGlobalContext, this);</span>
<span class="fc" id="L67">  }</span>

  /**
   * Replace variable placeholders in values of a map with syntax ${key} with values from the map itself.
   * The variables can recursively reference each other.
   * All escaped variables are deescaped.
   * @param config Config map with values with variable placeholders
   * @return Config map with values with variable placeholders resolved
   * @throws IllegalArgumentException when a variable name could not be resolve.d
   */
  public Map&lt;String, Object&gt; resolve(Map&lt;String, Object&gt; config) {
<span class="fc" id="L78">    return resolve(config, true);</span>
  }

  /**
   * Replace variable placeholders in values of a map with syntax ${key} with values from the map itself.
   * The variables can recursively reference each other.
   * @param config Config map with values with variable placeholders
   * @param deescapeVariables De-escape variables
   * @return Config map with values with variable placeholders resolved
   * @throws IllegalArgumentException when a variable name could not be resolved.
   */
  public Map&lt;String, Object&gt; resolve(Map&lt;String, Object&gt; config, boolean deescapeVariables) {
<span class="fc" id="L90">    return resolve(config, deescapeVariables, 0);</span>
  }

  /**
   * De-escapes all escaped variables in all string values in the given map.
   * @param config Config map with values that my contain escaped variable references (starting with \$)
   * @return Map with de-escaped variable references.
   */
  public Map&lt;String, Object&gt; deescape(Map&lt;String, Object&gt; config) {
<span class="fc" id="L99">    return deescapeMap(config);</span>
  }

  @SuppressWarnings(&quot;PMD.CompareObjectsWithEquals&quot;)
  private Map&lt;String, Object&gt; resolve(Map&lt;String, Object&gt; config, boolean deescapeVariables, int iterationCount) {
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">    if (iterationCount &gt;= REPLACEMENT_MAX_ITERATIONS) {</span>
<span class="nc" id="L105">      throw new IllegalArgumentException(&quot;Cyclic dependencies in config map detected: &quot; + config);</span>
    }

<span class="fc" id="L108">    Map&lt;String, Object&gt; mapCopy = replaceMap(config, config);</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">    boolean replacedAny = mapCopy != config;</span>

<span class="fc bfc" id="L111" title="All 2 branches covered.">    if (replacedAny) {</span>
      // try again until all nested references are resolved
<span class="fc" id="L113">      return resolve(mapCopy, deescapeVariables, iterationCount + 1);</span>
    }
    else {
<span class="fc bfc" id="L116" title="All 2 branches covered.">      if (deescapeVariables) {</span>
<span class="fc" id="L117">        return deescapeMap(config);</span>
      }
      else {
<span class="fc" id="L120">        return config;</span>
      }
    }
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  private Object replaceAny(Object value, Map&lt;String, Object&gt; variables) {
<span class="fc bfc" id="L127" title="All 2 branches covered.">    if (value instanceof String) {</span>
<span class="fc" id="L128">      return replaceObject((String)value, variables);</span>
    }
<span class="fc bfc" id="L130" title="All 2 branches covered.">    else if (value instanceof List) {</span>
<span class="fc" id="L131">      return replaceList((List&lt;Object&gt;)value, variables);</span>
    }
<span class="fc bfc" id="L133" title="All 2 branches covered.">    else if (value instanceof Map) {</span>
<span class="fc" id="L134">      Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;)value;</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">      if (map.containsKey(LIST_VARIABLE_ITERATE)) {</span>
<span class="fc" id="L136">        return replaceIterate(map, variables);</span>
      }
      else {
<span class="fc" id="L139">        return replaceMap(map, variables);</span>
      }
    }
    else {
<span class="fc" id="L143">      return value;</span>
    }
  }

  private Object replaceObject(String value, Map&lt;String, Object&gt; variables) {
<span class="fc" id="L148">    Object replacedValue = variableStringResolver.resolve(value, variables, false);</span>
<span class="pc bpc" id="L149" title="1 of 4 branches missed.">    if (replacedValue != null &amp;&amp; replacedValue.equals(value)) {</span>
<span class="fc" id="L150">      return value;</span>
    }
    else {
<span class="fc" id="L153">      return replacedValue;</span>
    }
  }

  @SuppressWarnings(&quot;PMD.CompareObjectsWithEquals&quot;)
  private List&lt;Object&gt; replaceList(List&lt;Object&gt; list, Map&lt;String, Object&gt; variables) {
<span class="fc" id="L159">    boolean replacedAny = false;</span>
<span class="fc" id="L160">    List&lt;Object&gt; listCopy = new ArrayList&lt;&gt;(list);</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">    for (int i = 0; i &lt; listCopy.size(); i++) {</span>
<span class="fc" id="L162">      Object item = listCopy.get(i);</span>
<span class="fc" id="L163">      Object replacedValue = replaceAny(item, variables);</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">      if (item != replacedValue) {</span>
<span class="fc" id="L165">        listCopy.set(i, replacedValue);</span>
<span class="fc" id="L166">        replacedAny = true;</span>
      }
    }
<span class="fc bfc" id="L169" title="All 2 branches covered.">    if (replacedAny) {</span>
<span class="fc" id="L170">      return listCopy;</span>
    }
    else {
<span class="fc" id="L173">      return list;</span>
    }
  }

  private Map&lt;String, Object&gt; replaceMap(Map&lt;String, Object&gt; map, Map&lt;String, Object&gt; variables) {
<span class="fc" id="L178">    Map&lt;String, Object&gt; mapCopy = new HashMap&lt;&gt;(map);</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">    boolean replacedAny = mapCopy.remove(LIST_VARIABLE_ITERATE) != null;</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">    for (Map.Entry&lt;String, Object&gt; entry : mapCopy.entrySet()) {</span>
<span class="fc" id="L181">      Object replacedValue = replaceAny(entry.getValue(), variables);</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">      if (entry.getValue() != replacedValue) {</span>
<span class="fc" id="L183">        entry.setValue(replacedValue);</span>
<span class="fc" id="L184">        replacedAny = true;</span>
      }
<span class="fc" id="L186">    }</span>

<span class="fc bfc" id="L188" title="All 2 branches covered.">    if (replacedAny) {</span>
<span class="fc" id="L189">      return mapCopy;</span>
    }
    else {
<span class="fc" id="L192">      return map;</span>
    }
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  private List&lt;Object&gt; replaceIterate(Map&lt;String, Object&gt; map, Map&lt;String, Object&gt; variables) {
<span class="fc" id="L198">    Object listObject = map.get(LIST_VARIABLE_ITERATE);</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">    if (listObject instanceof String) {</span>
<span class="fc" id="L200">      Matcher matcher = SINGLE_EXPRESSION_PATTERN.matcher((String)listObject);</span>
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">      if (matcher.matches()) {</span>
<span class="fc" id="L202">        listObject = variableStringResolver.resolve((String)listObject, variables);</span>
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">        if (listObject == null) {</span>
<span class="nc" id="L204">          throw new IllegalArgumentException(&quot;Unable to resolve variable: &quot; + matcher.group(0));</span>
        }
      }
    }
<span class="fc bfc" id="L208" title="All 2 branches covered.">    if (!(listObject instanceof List)) {</span>
      // allow to iterate over single values as well
<span class="fc" id="L210">      listObject = ImmutableList.of(listObject);</span>
    }
<span class="fc" id="L212">    Map&lt;String, Object&gt; variablesClone = new LinkedHashMap&lt;&gt;(Cloner.standard().deepClone(variables));</span>
<span class="fc" id="L213">    List&lt;Object&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L214">    int count = 0;</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">    for (Object item : (List&lt;Object&gt;)listObject) {</span>
<span class="fc" id="L216">      variablesClone.put(ITEM_VARIABLE, item);</span>
<span class="fc" id="L217">      variablesClone.put(ITEM_INDEX_VARIABLE, count++);</span>
<span class="fc" id="L218">      result.add(replaceMap(map, variablesClone));</span>
<span class="fc" id="L219">    }</span>
<span class="fc" id="L220">    return result;</span>
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  private Object deescapeAny(Object value) {
<span class="fc bfc" id="L225" title="All 2 branches covered.">    if (value instanceof String) {</span>
<span class="fc" id="L226">      return deescapeString((String)value);</span>
    }
<span class="fc bfc" id="L228" title="All 2 branches covered.">    else if (value instanceof List) {</span>
<span class="fc" id="L229">      return deescapeList((List&lt;Object&gt;)value);</span>
    }
<span class="fc bfc" id="L231" title="All 2 branches covered.">    else if (value instanceof Map) {</span>
<span class="fc" id="L232">      return deescapeMap((Map&lt;String, Object&gt;)value);</span>
    }
    else {
<span class="fc" id="L235">      return value;</span>
    }
  }

  private String deescapeString(String value) {
<span class="fc" id="L240">    return variableStringResolver.deescape(value);</span>
  }

  @SuppressWarnings(&quot;PMD.CompareObjectsWithEquals&quot;)
  private List&lt;Object&gt; deescapeList(List&lt;Object&gt; list) {
<span class="fc" id="L245">    List&lt;Object&gt; listCopy = new ArrayList&lt;&gt;(list);</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">    for (int i = 0; i &lt; listCopy.size(); i++) {</span>
<span class="fc" id="L247">      Object item = listCopy.get(i);</span>
<span class="fc" id="L248">      Object deescapedValue = deescapeAny(item);</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">      if (item != deescapedValue) {</span>
<span class="fc" id="L250">        listCopy.set(i, deescapedValue);</span>
      }
    }
<span class="fc" id="L253">    return listCopy;</span>
  }

  private Map&lt;String, Object&gt; deescapeMap(Map&lt;String, Object&gt; map) {
<span class="fc" id="L257">    Map&lt;String, Object&gt; mapCopy = new HashMap&lt;&gt;(map);</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">    for (Map.Entry&lt;String, Object&gt; entry : mapCopy.entrySet()) {</span>
<span class="fc" id="L259">      Object deescapedValue = deescapeAny(entry.getValue());</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">      if (entry.getValue() != deescapedValue) {</span>
<span class="fc" id="L261">        entry.setValue(deescapedValue);</span>
      }
<span class="fc" id="L263">    }</span>
<span class="fc" id="L264">    return mapCopy;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>