<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AllPackageBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CONGA AEM Maven Plugin</a> &gt; <a href="index.source.html" class="el_package">io.wcm.devops.conga.plugins.aem.maven.allpackage</a> &gt; <span class="el_source">AllPackageBuilder.java</span></div><h1>AllPackageBuilder.java</h1><pre class="source lang-java linenums">/*
 * #%L
 * wcm.io
 * %%
 * Copyright (C) 2020 wcm.io
 * %%
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package io.wcm.devops.conga.plugins.aem.maven.allpackage;

import static io.wcm.devops.conga.generator.util.FileUtil.getCanonicalPath;
import static io.wcm.devops.conga.plugins.aem.maven.allpackage.RunModeUtil.RUNMODE_AUTHOR;
import static io.wcm.devops.conga.plugins.aem.maven.allpackage.RunModeUtil.RUNMODE_PUBLISH;
import static io.wcm.devops.conga.plugins.aem.maven.allpackage.RunModeUtil.eliminateAuthorPublishDuplicates;
import static io.wcm.devops.conga.plugins.aem.maven.allpackage.RunModeUtil.isAuthorAndPublish;
import static io.wcm.devops.conga.plugins.aem.maven.allpackage.RunModeUtil.isOnlyAuthor;
import static io.wcm.devops.conga.plugins.aem.maven.allpackage.RunModeUtil.isOnlyPublish;
import static org.apache.jackrabbit.vault.packaging.PackageProperties.NAME_DEPENDENCIES;
import static org.apache.jackrabbit.vault.packaging.PackageProperties.NAME_NAME;
import static org.apache.jackrabbit.vault.packaging.PackageProperties.NAME_PACKAGE_TYPE;
import static org.apache.jackrabbit.vault.packaging.PackageProperties.NAME_VERSION;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Properties;
import java.util.Set;
import java.util.stream.Collectors;

import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;
import org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;
import org.apache.commons.compress.archivers.zip.ZipFile;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.Strings;
import org.apache.jackrabbit.vault.packaging.Dependency;
import org.apache.jackrabbit.vault.packaging.DependencyUtil;
import org.apache.jackrabbit.vault.packaging.PackageType;
import org.apache.jackrabbit.vault.packaging.VersionRange;
import org.apache.maven.artifact.ArtifactUtils;
import org.apache.maven.plugin.logging.Log;
import org.apache.maven.plugin.logging.SystemStreamLog;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import io.wcm.devops.conga.plugins.aem.maven.AutoDependenciesMode;
import io.wcm.devops.conga.plugins.aem.maven.BuildOutputTimestamp;
import io.wcm.devops.conga.plugins.aem.maven.PackageTypeValidation;
import io.wcm.devops.conga.plugins.aem.maven.PackageVersionMode;
import io.wcm.devops.conga.plugins.aem.maven.RunModeOptimization;
import io.wcm.devops.conga.plugins.aem.maven.model.BundleFile;
import io.wcm.devops.conga.plugins.aem.maven.model.ContentPackageFile;
import io.wcm.devops.conga.plugins.aem.maven.model.InstallableFile;
import io.wcm.tooling.commons.contentpackagebuilder.ContentPackage;
import io.wcm.tooling.commons.contentpackagebuilder.ContentPackageBuilder;
import io.wcm.tooling.commons.contentpackagebuilder.PackageFilter;

/**
 * Builds &quot;all&quot; package based on given set of content packages.
 *
 * &lt;p&gt;
 * General concept:
 * &lt;/p&gt;
 *
 * &lt;ul&gt;
 * &lt;li&gt;Iterates through all content packages that are generated or collected by CONGA and contained in the
 * model.json&lt;/li&gt;
 * &lt;li&gt;Enforces the order defined in CONGA by automatically adding dependencies to all packages reflecting the file
 * order in model.json&lt;/li&gt;
 * &lt;li&gt;Because the dependency chain may be different for each runmode (author/publish), each package is added once for
 * each runmode. Internally this separate dependency change for author and publish is optimized to have each package
 * included only once for author+publish, unless it has a different chain of dependencies for both runmodes, in which
 * case it is included separately for each run mode.&lt;/li&gt;
 * &lt;li&gt;To avoid conflicts with duplicate packages with different dependency chains the names of packages that are
 * included in different versions for author/publish are changed and a runmode suffix (.author or .publish) is added,
 * and it is put in a corresponding install folder.&lt;/li&gt;
 * &lt;li&gt;To avoid problems with nested sub packages, the sub packages are extracted from the packages and treated in the
 * same way as other packages.&lt;/li&gt;
 * &lt;/ul&gt;
 */
public final class AllPackageBuilder {

  private final File targetFile;
  private final String groupName;
  private final String packageName;
  private String version;
<span class="fc" id="L111">  private AutoDependenciesMode autoDependenciesMode = AutoDependenciesMode.OFF;</span>
<span class="fc" id="L112">  private RunModeOptimization runModeOptimization = RunModeOptimization.OFF;</span>
<span class="fc" id="L113">  private PackageTypeValidation packageTypeValidation = PackageTypeValidation.STRICT;</span>
<span class="fc" id="L114">  private PackageVersionMode packageVersionMode = PackageVersionMode.DEFAULT;</span>
  private Log log;
  private BuildOutputTimestamp buildOutputTimestamp;

  private static final String RUNMODE_DEFAULT = &quot;$default$&quot;;
<span class="fc" id="L119">  private static final Set&lt;String&gt; ALLOWED_PACKAGE_TYPES = Set.of(</span>
<span class="fc" id="L120">      PackageType.APPLICATION.name().toLowerCase(),</span>
<span class="fc" id="L121">      PackageType.CONTAINER.name().toLowerCase(),</span>
<span class="fc" id="L122">      PackageType.CONTENT.name().toLowerCase());</span>
  private static final String VERSION_SUFFIX_SEPARATOR = &quot;-&quot;;

<span class="fc" id="L125">  private final List&lt;ContentPackageFileSet&gt; contentPackageFileSets = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L126">  private final List&lt;BundleFileSet&gt; bundleFileSets = new ArrayList&lt;&gt;();</span>

  /**
   * Constructor.
   * @param targetFile Target file
   * @param groupName Group name
   * @param packageName Package name
   */
<span class="fc" id="L134">  public AllPackageBuilder(File targetFile, String groupName, String packageName) {</span>
<span class="fc" id="L135">    this.targetFile = targetFile;</span>
<span class="fc" id="L136">    this.groupName = groupName;</span>
<span class="fc" id="L137">    this.packageName = packageName;</span>
<span class="fc" id="L138">  }</span>

  /**
   * Automatically generate dependencies between content packages based on file order in CONGA configuration.
   * @param value mode
   * @return this
   */
  public AllPackageBuilder autoDependenciesMode(AutoDependenciesMode value) {
<span class="fc" id="L146">    this.autoDependenciesMode = value;</span>
<span class="fc" id="L147">    return this;</span>
  }

  /**
   * Configure run mode optimization.
   * @param value mode
   * @return this
   */
  public AllPackageBuilder runModeOptimization(RunModeOptimization value) {
<span class="fc" id="L156">    this.runModeOptimization = value;</span>
<span class="fc" id="L157">    return this;</span>
  }

  /**
   * How to validate package types to be included in &quot;all&quot; package.
   * @param value validation
   * @return this
   */
  public AllPackageBuilder packageTypeValidation(PackageTypeValidation value) {
<span class="fc" id="L166">    this.packageTypeValidation = value;</span>
<span class="fc" id="L167">    return this;</span>
  }

  /**
   * How to handle versions of packages and sub-packages inside &quot;all&quot; package.
   * @param value mode
   * @return this
   */
  public AllPackageBuilder packageVersionMode(PackageVersionMode value) {
<span class="fc" id="L176">    this.packageVersionMode = value;</span>
<span class="fc" id="L177">    return this;</span>
  }

  /**
   * Maven logger
   * @param value Maven logger
   * @return this
   */
  public AllPackageBuilder logger(Log value) {
<span class="fc" id="L186">    this.log = value;</span>
<span class="fc" id="L187">    return this;</span>
  }

  /**
   * Package version
   * @param value Package version
   * @return this
   */
  public AllPackageBuilder version(String value) {
<span class="fc" id="L196">    this.version = value;</span>
<span class="fc" id="L197">    return this;</span>
  }

  /**
   * Build output timestamp
   * @param value timestamp
   * @return this
   */
  public AllPackageBuilder buildOutputTimestamp(BuildOutputTimestamp value) {
<span class="fc" id="L206">    this.buildOutputTimestamp = value;</span>
<span class="fc" id="L207">    return this;</span>
  }

  private Log getLog() {
<span class="fc bfc" id="L211" title="All 2 branches covered.">    if (this.log == null) {</span>
<span class="fc" id="L212">      this.log = new SystemStreamLog();</span>
    }
<span class="fc" id="L214">    return this.log;</span>
  }

  /**
   * Add content packages and OSGi bundles to be contained in &quot;all&quot; content package.
   * @param files Content packages (invalid will be filtered out) and OSGi bundles
   * @param cloudManagerTarget Target environments/run modes the packages should be attached to
   * @throws IllegalArgumentException If and invalid package type is detected
   */
  public void add(List&lt;InstallableFile&gt; files, Set&lt;String&gt; cloudManagerTarget) {
<span class="fc" id="L224">    List&lt;ContentPackageFile&gt; contentPackages = filterFiles(files, ContentPackageFile.class);</span>

    // collect list of cloud manager environment run modes
<span class="fc" id="L227">    List&lt;String&gt; environmentRunModes = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">    if (cloudManagerTarget.isEmpty()) {</span>
<span class="fc" id="L229">      environmentRunModes.add(RUNMODE_DEFAULT);</span>
    }
    else {
<span class="fc" id="L232">      environmentRunModes.addAll(cloudManagerTarget);</span>
    }

    List&lt;ContentPackageFile&gt; validContentPackages;
<span class="pc bpc" id="L236" title="1 of 3 branches missed.">    switch (packageTypeValidation) {</span>
      case STRICT:
<span class="fc" id="L238">        validContentPackages = getValidContentPackagesStrictValidation(contentPackages);</span>
<span class="fc" id="L239">        break;</span>
      case WARN:
<span class="fc" id="L241">        validContentPackages = getValidContentPackagesWarnValidation(contentPackages);</span>
<span class="fc" id="L242">        break;</span>
      default:
<span class="nc" id="L244">        throw new IllegalArgumentException(&quot;Unsupported package type validation: &quot; + packageTypeValidation);</span>
    }

<span class="fc bfc" id="L247" title="All 2 branches covered.">    if (!validContentPackages.isEmpty()) {</span>
<span class="fc" id="L248">      contentPackageFileSets.add(new ContentPackageFileSet(validContentPackages, environmentRunModes));</span>
    }

    // add OSGi bundles
<span class="fc" id="L252">    List&lt;BundleFile&gt; bundles = filterFiles(files, BundleFile.class);</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">    if (!bundles.isEmpty()) {</span>
<span class="fc" id="L254">      bundleFileSets.add(new BundleFileSet(bundles, environmentRunModes));</span>
    }
<span class="fc" id="L256">  }</span>

  /**
   * Get valid content packages in strict mode: Ignore content packages without package type (with warning),
   * fail build if Content package with &quot;mixed&quot; mode is found.
   * @param contentPackages Content packages
   * @return Valid content packages
   */
  private List&lt;ContentPackageFile&gt; getValidContentPackagesStrictValidation(List&lt;? extends ContentPackageFile&gt; contentPackages) {
    // generate warning for each content packages without package type that is skipped
<span class="fc" id="L266">    contentPackages.stream()</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">        .filter(pkg -&gt; !hasPackageType(pkg))</span>
<span class="fc" id="L268">        .forEach(pkg -&gt; getLog().warn(&quot;Skipping content package without package type: &quot; + getCanonicalPath(pkg.getFile())));</span>

    // fail build if content packages with non-allowed package types exist
<span class="fc" id="L271">    List&lt;ContentPackageFile&gt; invalidPackageTypeContentPackages = contentPackages.stream()</span>
<span class="fc" id="L272">        .filter(AllPackageBuilder::hasPackageType)</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">        .filter(pkg -&gt; !isValidPackageType(pkg))</span>
<span class="fc" id="L274">        .collect(Collectors.toList());</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">    if (!invalidPackageTypeContentPackages.isEmpty()) {</span>
<span class="fc" id="L276">      throw new IllegalArgumentException(&quot;Content packages found with unsupported package types: &quot; +</span>
<span class="fc" id="L277">          invalidPackageTypeContentPackages.stream()</span>
<span class="fc" id="L278">              .map(pkg -&gt; pkg.getName() + &quot; -&gt; &quot; + pkg.getPackageType())</span>
<span class="fc" id="L279">              .collect(Collectors.joining(&quot;, &quot;)));</span>
    }

    // collect AEM content packages with package type
<span class="fc" id="L283">    return contentPackages.stream()</span>
<span class="fc" id="L284">        .filter(AllPackageBuilder::hasPackageType)</span>
<span class="fc" id="L285">        .collect(Collectors.toList());</span>
  }

  /**
   * Get all content packages, generate warnings if package type is missing or &quot;mixed&quot; mode package type is used.
   * @param contentPackages Content packages
   * @return Valid content packages
   */
  private List&lt;ContentPackageFile&gt; getValidContentPackagesWarnValidation(List&lt;? extends ContentPackageFile&gt; contentPackages) {
    // generate warning for each content packages without package type
<span class="fc" id="L295">    contentPackages.stream()</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">        .filter(pkg -&gt; !hasPackageType(pkg))</span>
<span class="fc" id="L297">        .forEach(pkg -&gt; getLog().warn(&quot;Found content package without package type: &quot; + getCanonicalPath(pkg.getFile())));</span>

    // generate warning for each content packages with invalid package type
<span class="fc" id="L300">    contentPackages.stream()</span>
<span class="fc" id="L301">        .filter(AllPackageBuilder::hasPackageType)</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">        .filter(pkg -&gt; !isValidPackageType(pkg))</span>
<span class="fc" id="L303">        .forEach(pkg -&gt; getLog().warn(&quot;Found content package with invalid package type: &quot;</span>
<span class="fc" id="L304">            + getCanonicalPath(pkg.getFile()) + &quot; -&gt; &quot; + pkg.getPackageType()));</span>

    // return all content packages
<span class="fc" id="L307">    return contentPackages.stream().collect(Collectors.toList());</span>
  }

  private static &lt;T&gt; List&lt;T&gt; filterFiles(List&lt;? extends InstallableFile&gt; files, Class&lt;T&gt; fileClass) {
<span class="fc" id="L311">    return files.stream()</span>
<span class="fc" id="L312">        .filter(fileClass::isInstance)</span>
<span class="fc" id="L313">        .map(fileClass::cast)</span>
<span class="fc" id="L314">        .toList();</span>
  }

  /**
   * Build &quot;all&quot; content package.
   * @param properties Specifies additional properties to be set in the properties.xml file.
   * @return true if &quot;all&quot; package was generated, false if no valid package was found.
   * @throws IOException I/O exception
   */
  public boolean build(Map&lt;String, String&gt; properties) throws IOException {

<span class="fc bfc" id="L325" title="All 2 branches covered.">    if (contentPackageFileSets.isEmpty()) {</span>
<span class="fc" id="L326">      return false;</span>
    }

    // prepare content package metadata
<span class="fc" id="L330">    ContentPackageBuilder builder = new ContentPackageBuilder()</span>
<span class="fc" id="L331">        .group(groupName)</span>
<span class="fc" id="L332">        .name(packageName)</span>
<span class="fc" id="L333">        .packageType(&quot;container&quot;);</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">    if (version != null) {</span>
<span class="fc" id="L335">      builder.version(version);</span>
    }

    // define root path for &quot;all&quot; package
<span class="fc" id="L339">    String rootPath = buildRootPath(groupName, packageName);</span>
<span class="fc" id="L340">    builder.filter(new PackageFilter(rootPath));</span>

    // additional package properties
<span class="fc bfc" id="L343" title="All 2 branches covered.">    if (properties != null) {</span>
<span class="fc" id="L344">      properties.entrySet().forEach(entry -&gt; builder.property(entry.getKey(), entry.getValue()));</span>
    }

    // build content package
<span class="fc" id="L348">    try (ContentPackage contentPackage = builder.build(targetFile)) {</span>
<span class="fc" id="L349">      buildAddContentPackages(contentPackage, rootPath);</span>
<span class="fc" id="L350">      buildAddBundles(contentPackage, rootPath);</span>
    }

<span class="fc" id="L353">    return true;</span>
  }

  @SuppressWarnings(&quot;java:S3776&quot;) // ignore complexity
  private void buildAddContentPackages(ContentPackage contentPackage, String rootPath) throws IOException {
    // build set with dependencies instances for each package contained in all filesets
<span class="fc" id="L359">    Set&lt;Dependency&gt; allPackagesFromFileSets = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">    for (ContentPackageFileSet fileSet : contentPackageFileSets) {</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">      for (ContentPackageFile pkg : fileSet.getFiles()) {</span>
<span class="fc" id="L362">        addDependencyInformation(allPackagesFromFileSets, pkg);</span>
<span class="fc" id="L363">      }</span>
<span class="fc" id="L364">    }</span>

    Collection&lt;ContentPackageFileSet&gt; processedFileSets;
<span class="fc bfc" id="L367" title="All 2 branches covered.">    if (runModeOptimization == RunModeOptimization.ELIMINATE_DUPLICATES) {</span>
      // eliminate duplicates which are same for author and publish
<span class="fc" id="L369">      processedFileSets = eliminateAuthorPublishDuplicates(contentPackageFileSets,</span>
<span class="fc" id="L370">        environmentRunMode -&gt; new ContentPackageFileSet(new ArrayList&lt;&gt;(), Collections.singletonList(environmentRunMode)));</span>
    }
    else {
<span class="fc" id="L373">      processedFileSets = contentPackageFileSets;</span>
    }

<span class="fc bfc" id="L376" title="All 2 branches covered.">    for (ContentPackageFileSet fileSet : processedFileSets) {</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">      for (String environmentRunMode : fileSet.getEnvironmentRunModes()) {</span>
<span class="fc" id="L378">        List&lt;ContentPackageFile&gt; previousPackages = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">        for (ContentPackageFile pkg : fileSet.getFiles()) {</span>
<span class="fc" id="L380">          ContentPackageFile previousPkg = getDependencyChainPreviousPackage(pkg, previousPackages);</span>

          // set package name, wire previous package in package dependency
<span class="fc" id="L383">          List&lt;TemporaryContentPackageFile&gt; processedFiles = processContentPackage(pkg, previousPkg, environmentRunMode, allPackagesFromFileSets);</span>

          // add processed content packages to &quot;all&quot; content package - and delete the temporary files
          try {
<span class="fc bfc" id="L387" title="All 2 branches covered.">            for (TemporaryContentPackageFile processedFile : processedFiles) {</span>
<span class="fc" id="L388">              String path = buildPackagePath(processedFile, rootPath, environmentRunMode);</span>
<span class="fc" id="L389">              contentPackage.addFile(path, processedFile.getFile());</span>
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">              if (log.isDebugEnabled()) {</span>
<span class="nc" id="L391">                log.debug(&quot;  Add &quot; + processedFile.getPackageInfoWithDependencies());</span>
              }
<span class="fc" id="L393">            }</span>
          }
          finally {
<span class="fc" id="L396">            processedFiles.stream()</span>
<span class="fc" id="L397">                .map(TemporaryContentPackageFile::getFile)</span>
<span class="fc" id="L398">                .forEach(FileUtils::deleteQuietly);</span>
          }

<span class="fc" id="L401">          previousPackages.add(pkg);</span>
<span class="fc" id="L402">        }</span>
<span class="fc" id="L403">      }</span>
<span class="fc" id="L404">    }</span>
<span class="fc" id="L405">  }</span>

  /**
   * Gets the previous package in the order defined by CONGA to define as package dependency in current package.
   * @param currentPackage Current package
   * @param previousPackages List of previous packages
   * @return Package to define as dependency, or null if no dependency should be defined
   */
  private @Nullable ContentPackageFile getDependencyChainPreviousPackage(@NotNull ContentPackageFile currentPackage,
      @NotNull List&lt;ContentPackageFile&gt; previousPackages) {
<span class="fc bfc" id="L415" title="All 4 branches covered.">    if ((autoDependenciesMode == AutoDependenciesMode.OFF)</span>
<span class="fc bfc" id="L416" title="All 2 branches covered.">        || (autoDependenciesMode == AutoDependenciesMode.IMMUTABLE_ONLY &amp;&amp; isMutable(currentPackage))) {</span>
<span class="fc" id="L417">      return null;</span>
    }
    // get last previous package
<span class="fc" id="L420">    return previousPackages.stream()</span>
        // if not IMMUTABLE_MUTABLE_COMBINED active only that of the same mutability type
<span class="fc bfc" id="L422" title="All 4 branches covered.">        .filter(item -&gt; (autoDependenciesMode == AutoDependenciesMode.IMMUTABLE_MUTABLE_COMBINED) || mutableMatches(item, currentPackage))</span>
        // make sure author-only or publish-only packages are only taken into account if the current package has same restriction
<span class="fc bfc" id="L424" title="All 2 branches covered.">        .filter(item -&gt; isAuthorAndPublish(item)</span>
<span class="fc bfc" id="L425" title="All 4 branches covered.">            || (isOnlyAuthor(item) &amp;&amp; isOnlyAuthor(currentPackage))</span>
<span class="pc bpc" id="L426" title="1 of 4 branches missed.">            || (isOnlyPublish(item) &amp;&amp; isOnlyPublish(currentPackage)))</span>
        // ignore packages that are marked as dependency chain ignore
<span class="fc bfc" id="L428" title="All 2 branches covered.">        .filter(item -&gt; !item.isDependencyChainIgnore())</span>
        // get last in list
<span class="fc" id="L430">        .reduce((first, second) -&gt; second).orElse(null);</span>
  }

  private void buildAddBundles(ContentPackage contentPackage, String rootPath) throws IOException {
    Collection&lt;BundleFileSet&gt; processedFileSets;
<span class="fc bfc" id="L435" title="All 2 branches covered.">    if (runModeOptimization == RunModeOptimization.ELIMINATE_DUPLICATES) {</span>
      // eliminate duplicates which are same for author and publish
<span class="fc" id="L437">      processedFileSets = eliminateAuthorPublishDuplicates(bundleFileSets,</span>
<span class="fc" id="L438">          environmentRunMode -&gt; new BundleFileSet(new ArrayList&lt;&gt;(), Collections.singletonList(environmentRunMode)));</span>
    }
    else {
<span class="fc" id="L441">      processedFileSets = bundleFileSets;</span>
    }

<span class="fc bfc" id="L444" title="All 2 branches covered.">    for (BundleFileSet bundleFileSet : processedFileSets) {</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">      for (String environmentRunMode : bundleFileSet.getEnvironmentRunModes()) {</span>
<span class="fc bfc" id="L446" title="All 2 branches covered.">        for (BundleFile bundleFile : bundleFileSet.getFiles()) {</span>
<span class="fc" id="L447">          String path = buildBundlePath(bundleFile, rootPath, environmentRunMode);</span>
<span class="fc" id="L448">          contentPackage.addFile(path, bundleFile.getFile());</span>
<span class="fc" id="L449">        }</span>
<span class="fc" id="L450">      }</span>
<span class="fc" id="L451">    }</span>
<span class="fc" id="L452">  }</span>

  private static boolean hasPackageType(ContentPackageFile pkg) {
    // accept only content packages with a package type set
<span class="fc bfc" id="L456" title="All 2 branches covered.">    return pkg.getPackageType() != null;</span>
  }

  private static boolean isValidPackageType(ContentPackageFile pkg) {
    // check if the package type is an allowed package type
<span class="fc" id="L461">    return ALLOWED_PACKAGE_TYPES.contains(pkg.getPackageType());</span>
  }

  private static boolean isMutable(ContentPackageFile pkg) {
<span class="fc" id="L465">    return Strings.CS.equals(&quot;content&quot;, pkg.getPackageType());</span>
  }

  private static boolean mutableMatches(ContentPackageFile pkg1, ContentPackageFile pkg2) {
<span class="pc bpc" id="L469" title="2 of 4 branches missed.">    if (pkg1 == null || pkg2 == null) {</span>
<span class="nc" id="L470">      return false;</span>
    }
<span class="fc bfc" id="L472" title="All 2 branches covered.">    return isMutable(pkg1) == isMutable(pkg2);</span>
  }

  /**
   * Build root path to be used for embedded package.
   * @param groupName Group name
   * @param packageName Package name
   * @return Package path
   */
  private static String buildRootPath(String groupName, String packageName) {
<span class="fc" id="L482">    return &quot;/apps/&quot; + groupName + &quot;-&quot; + packageName + &quot;-packages&quot;;</span>
  }

  /**
   * Generate suffix for instance and environment run modes.
   * @param file File
   * @return Suffix string
   */
  private static String buildRunModeSuffix(InstallableFile file, String environmentRunMode) {
<span class="fc" id="L491">    StringBuilder runModeSuffix = new StringBuilder();</span>
<span class="fc bfc" id="L492" title="All 2 branches covered.">    if (isOnlyAuthor(file)) {</span>
<span class="fc" id="L493">      runModeSuffix.append(&quot;.&quot;).append(RUNMODE_AUTHOR);</span>
    }
<span class="fc bfc" id="L495" title="All 2 branches covered.">    else if (isOnlyPublish(file)) {</span>
<span class="fc" id="L496">      runModeSuffix.append(&quot;.&quot;).append(RUNMODE_PUBLISH);</span>
    }
<span class="fc bfc" id="L498" title="All 2 branches covered.">    if (!Strings.CS.equals(environmentRunMode, RUNMODE_DEFAULT)) {</span>
<span class="fc" id="L499">      runModeSuffix.append(&quot;.&quot;).append(environmentRunMode);</span>
    }
<span class="fc" id="L501">    return runModeSuffix.toString();</span>
  }

  /**
   * Generate suffix for versions of content packages.
   * @param pkg Content package
   * @param ignoreSnapshot Do not build version suffix for SNAPSHOT versions
   * @return Suffix string
   */
  private String buildVersionSuffix(ContentPackageFile pkg, boolean ignoreSnapshot) {
<span class="fc" id="L511">    StringBuilder versionSuffix = new StringBuilder();</span>

<span class="fc bfc" id="L513" title="All 2 branches covered.">    if (this.packageVersionMode == PackageVersionMode.RELEASE_SUFFIX_VERSION</span>
<span class="fc bfc" id="L514" title="All 4 branches covered.">        &amp;&amp; (!ArtifactUtils.isSnapshot(pkg.getVersion()) || !ignoreSnapshot)</span>
<span class="pc bpc" id="L515" title="1 of 4 branches missed.">        &amp;&amp; !Strings.CS.equals(pkg.getVersion(), this.version)</span>
        &amp;&amp; this.version != null) {
<span class="fc" id="L517">      versionSuffix.append(VERSION_SUFFIX_SEPARATOR)</span>
          // replace dots with underlines in version suffix to avoid confusion with main version number
<span class="fc" id="L519">          .append(Strings.CS.replace(this.version, &quot;.&quot;, &quot;_&quot;));</span>
    }

<span class="fc" id="L522">    return versionSuffix.toString();</span>
  }

  /**
   * Build path to be used for embedded package.
   * @param pkg Package
   * @param rootPath Root path
   * @return Package path
   */
  @SuppressWarnings(&quot;java:S1075&quot;) // no filesystem path
  private String buildPackagePath(ContentPackageFile pkg, String rootPath, String environmentRunMode) {
<span class="pc bpc" id="L533" title="1 of 4 branches missed.">    if (packageTypeValidation == PackageTypeValidation.STRICT &amp;&amp; !isValidPackageType(pkg)) {</span>
<span class="nc" id="L534">      throw new IllegalArgumentException(&quot;Package &quot; + pkg.getPackageInfo() + &quot; has invalid package type: '&quot; + pkg.getPackageType() + &quot;'.&quot;);</span>
    }

<span class="fc" id="L537">    String runModeSuffix = buildRunModeSuffix(pkg, environmentRunMode);</span>

    // add run mode suffix to both install folder path and package file name
<span class="fc" id="L540">    String path = rootPath + &quot;/&quot; + Objects.toString(pkg.getPackageType(), &quot;misc&quot;) + &quot;/install&quot; + runModeSuffix;</span>

<span class="fc" id="L542">    String versionSuffix = &quot;&quot;;</span>
<span class="fc" id="L543">    String packageVersion = pkg.getVersion();</span>
<span class="fc" id="L544">    String packageVersionWithoutSuffix = packageVersion;</span>
<span class="pc bpc" id="L545" title="1 of 4 branches missed.">    if (this.packageVersionMode == PackageVersionMode.RELEASE_SUFFIX_VERSION &amp;&amp; this.version != null) {</span>
<span class="fc" id="L546">      packageVersionWithoutSuffix = Strings.CS.removeEnd(packageVersion, buildVersionSuffix(pkg, false));</span>
    }
<span class="pc bpc" id="L548" title="1 of 4 branches missed.">    if (packageVersion != null &amp;&amp; pkg.getFile().getName().contains(packageVersionWithoutSuffix)) {</span>
<span class="fc" id="L549">      versionSuffix = &quot;-&quot; + packageVersion;</span>
    }
<span class="fc" id="L551">    String fileName = pkg.getName() + versionSuffix</span>
<span class="fc" id="L552">        + &quot;.&quot; + FilenameUtils.getExtension(pkg.getFile().getName());</span>
<span class="fc" id="L553">    return path + &quot;/&quot; + fileName;</span>
  }

  /**
   * Build path to be used for embedded bundle.
   * @param bundleFile Bundle
   * @param rootPath Root path
   * @return Package path
   */
  private static String buildBundlePath(BundleFile bundleFile, String rootPath, String environmentRunMode) {
<span class="fc" id="L563">    String runModeSuffix = buildRunModeSuffix(bundleFile, environmentRunMode);</span>

    // add run mode suffix to both install folder path and package file name
<span class="fc" id="L566">    String path = rootPath + &quot;/application/install&quot; + runModeSuffix;</span>

<span class="fc" id="L568">    return path + &quot;/&quot; + bundleFile.getFile().getName();</span>
  }

  /**
   * Rewrite content package ZIP file while adding to &quot;all&quot; package:
   * Add dependency to previous package in CONGA configuration file oder.
   * @param pkg Package to process (can be parent packe of the actual file)
   * @param previousPkg Previous package to get dependency information from.
   *          Is null if no previous package exists or auto dependency mode is switched off.
   * @param environmentRunMode Environment run mode
   * @param allPackagesFromFileSets Set with all packages from all file sets as dependency instances
   * @return Returns a list of content package *temporary* files - have to be deleted when processing is completed.
   * @throws IOException I/O error
   */
  @SuppressWarnings(&quot;java:S3776&quot;) // ignore complexity
  private List&lt;TemporaryContentPackageFile&gt; processContentPackage(ContentPackageFile pkg,
      ContentPackageFile previousPkg, String environmentRunMode,
      Set&lt;Dependency&gt; allPackagesFromFileSets) throws IOException {

<span class="fc" id="L587">    List&lt;TemporaryContentPackageFile&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L588">    List&lt;TemporaryContentPackageFile&gt; subPackages = new ArrayList&lt;&gt;();</span>

    // create temp zip file to create rewritten copy of package
<span class="fc" id="L591">    File tempFile = File.createTempFile(FilenameUtils.getBaseName(pkg.getFile().getName()), &quot;.zip&quot;);</span>

    // open original content package
<span class="fc" id="L594">    try (ZipFile zipFileIn = new ZipFile.Builder().setFile(pkg.getFile()).get()) {</span>

      // iterate through entries and write them to the temp. zip file
<span class="fc" id="L597">      try (FileOutputStream fos = new FileOutputStream(tempFile);</span>
<span class="fc" id="L598">          ZipArchiveOutputStream zipOut = new ZipArchiveOutputStream(fos)) {</span>
<span class="fc" id="L599">        Enumeration&lt;? extends ZipArchiveEntry&gt; zipInEntries = zipFileIn.getEntries();</span>
<span class="fc bfc" id="L600" title="All 2 branches covered.">        while (zipInEntries.hasMoreElements()) {</span>
<span class="fc" id="L601">          ZipArchiveEntry zipInEntry = zipInEntries.nextElement();</span>
<span class="fc bfc" id="L602" title="All 2 branches covered.">          if (!zipInEntry.isDirectory()) {</span>
<span class="fc" id="L603">            try (InputStream is = zipFileIn.getInputStream(zipInEntry)) {</span>
<span class="fc" id="L604">              boolean processedEntry = false;</span>

              // if entry is properties.xml, update dependency information
<span class="fc bfc" id="L607" title="All 2 branches covered.">              if (Strings.CS.equals(zipInEntry.getName(), &quot;META-INF/vault/properties.xml&quot;)) {</span>
<span class="fc" id="L608">                FileVaultProperties fileVaultProps = new FileVaultProperties(is);</span>
<span class="fc" id="L609">                Properties props = fileVaultProps.getProperties();</span>
<span class="fc" id="L610">                addSuffixToPackageName(props, pkg, environmentRunMode);</span>
<span class="fc" id="L611">                addSuffixToVersion(props, pkg);</span>

                // update package dependencies
<span class="fc" id="L614">                ContentPackageFile dependencyFile = previousPkg;</span>
<span class="fc bfc" id="L615" title="All 4 branches covered.">                if (autoDependenciesMode == AutoDependenciesMode.OFF || pkg.isDependencyChainIgnore()) {</span>
<span class="fc" id="L616">                  dependencyFile = null;</span>
                }
<span class="fc" id="L618">                updateDependencies(pkg, props, dependencyFile, environmentRunMode, allPackagesFromFileSets);</span>

                // if package type is missing in package properties, put in the type defined in model
<span class="fc" id="L621">                String packageType = pkg.getPackageType();</span>
<span class="fc bfc" id="L622" title="All 4 branches covered.">                if (props.get(NAME_PACKAGE_TYPE) == null &amp;&amp; packageType != null) {</span>
<span class="fc" id="L623">                  props.put(NAME_PACKAGE_TYPE, packageType);</span>
                }

<span class="fc" id="L626">                ZipArchiveEntry zipOutEntry = newZipEntry(zipInEntry);</span>
<span class="fc" id="L627">                zipOut.putArchiveEntry(zipOutEntry);</span>
<span class="fc" id="L628">                fileVaultProps.storeToXml(zipOut);</span>
<span class="fc" id="L629">                zipOut.closeArchiveEntry();</span>
<span class="fc" id="L630">                processedEntry = true;</span>
<span class="fc" id="L631">              }</span>

              // process sub-packages as well: add runmode suffix and update dependencies
<span class="fc bfc" id="L634" title="All 2 branches covered.">              else if (Strings.CS.equals(FilenameUtils.getExtension(zipInEntry.getName()), &quot;zip&quot;)) {</span>
<span class="fc" id="L635">                File tempSubPackageFile = File.createTempFile(FilenameUtils.getBaseName(zipInEntry.getName()), &quot;.zip&quot;);</span>
<span class="fc" id="L636">                try (FileOutputStream subPackageFos = new FileOutputStream(tempSubPackageFile)) {</span>
<span class="fc" id="L637">                  IOUtils.copy(is, subPackageFos);</span>
                }

                // check if contained ZIP file is really a content package
                // then process it as well, remove if from the content package is was contained in
                // and add it as &quot;1st level package&quot; to the all package
<span class="fc" id="L643">                TemporaryContentPackageFile tempSubPackage = new TemporaryContentPackageFile(tempSubPackageFile, pkg.getVariants());</span>
<span class="pc bpc" id="L644" title="1 of 4 branches missed.">                if (packageTypeValidation == PackageTypeValidation.STRICT &amp;&amp; !isValidPackageType(tempSubPackage)) {</span>
<span class="nc" id="L645">                  throw new IllegalArgumentException(&quot;Package &quot; + pkg.getPackageInfo() + &quot; contains sub package &quot; + tempSubPackage.getPackageInfo()</span>
<span class="nc" id="L646">                      + &quot; with invalid package type: '&quot; + StringUtils.defaultString(tempSubPackage.getPackageType()) + &quot;'&quot;);</span>
                }
<span class="pc bpc" id="L648" title="1 of 2 branches missed.">                if (StringUtils.isNoneBlank(tempSubPackage.getGroup(), tempSubPackage.getName())) {</span>
<span class="fc" id="L649">                  subPackages.add(tempSubPackage);</span>
<span class="fc" id="L650">                  processedEntry = true;</span>
                }
                else {
<span class="nc" id="L653">                  FileUtils.deleteQuietly(tempSubPackageFile);</span>
                }
              }

              // otherwise transfer the binary data 1:1
<span class="fc bfc" id="L658" title="All 2 branches covered.">              if (!processedEntry) {</span>
<span class="fc" id="L659">                ZipArchiveEntry zipOutEntry = newZipEntry(zipInEntry);</span>
<span class="fc" id="L660">                zipOut.putArchiveEntry(zipOutEntry);</span>
<span class="fc" id="L661">                IOUtils.copy(is, zipOut);</span>
<span class="fc" id="L662">                zipOut.closeArchiveEntry();</span>
              }
            }

          }
<span class="fc" id="L667">        }</span>
      }

      // add sub package metadata to set with dependency information
<span class="fc bfc" id="L671" title="All 2 branches covered.">      for (TemporaryContentPackageFile tempSubPackage : subPackages) {</span>
<span class="fc" id="L672">        addDependencyInformation(allPackagesFromFileSets, tempSubPackage);</span>
<span class="fc" id="L673">      }</span>

      // process sub packages and add to result
<span class="fc bfc" id="L676" title="All 2 branches covered.">      for (TemporaryContentPackageFile tempSubPackage : subPackages) {</span>
<span class="fc" id="L677">        result.addAll(processContentPackage(tempSubPackage, previousPkg, environmentRunMode, allPackagesFromFileSets));</span>
<span class="fc" id="L678">      }</span>

<span class="fc" id="L680">      result.add(new TemporaryContentPackageFile(tempFile, pkg.getVariants()));</span>
    }
<span class="fc" id="L682">    return result;</span>
  }

  private ZipArchiveEntry newZipEntry(ZipArchiveEntry in) {
<span class="fc" id="L686">    ZipArchiveEntry out = new ZipArchiveEntry(in.getName());</span>
<span class="fc bfc" id="L687" title="All 4 branches covered.">    if (buildOutputTimestamp != null &amp;&amp; buildOutputTimestamp.isValid()) {</span>
<span class="fc" id="L688">      out.setLastModifiedTime(buildOutputTimestamp.toFileTime());</span>
    }
<span class="pc bpc" id="L690" title="1 of 2 branches missed.">    else if (in.getLastModifiedTime() != null) {</span>
<span class="fc" id="L691">      out.setLastModifiedTime(in.getLastModifiedTime());</span>
    }
<span class="fc" id="L693">    return out;</span>
  }

  /**
   * Add dependency information to dependencies string in properties (if it does not exist already).
   * @param pkg Current content package
   * @param props Properties
   * @param dependencyFile Dependency package
   * @param allPackagesFromFileSets Set with all packages from all file sets as dependency instances
   */
  private void updateDependencies(ContentPackageFile pkg, Properties props, ContentPackageFile dependencyFile,
      String environmentRunMode, Set&lt;Dependency&gt; allPackagesFromFileSets) {
<span class="fc" id="L705">    String[] existingDepsStrings = StringUtils.split(props.getProperty(NAME_DEPENDENCIES), &quot;,&quot;);</span>
<span class="fc" id="L706">    Dependency[] existingDeps = null;</span>
<span class="fc bfc" id="L707" title="All 4 branches covered.">    if (existingDepsStrings != null &amp;&amp; existingDepsStrings.length &gt; 0) {</span>
<span class="fc" id="L708">      existingDeps = Dependency.fromString(existingDepsStrings);</span>
    }
<span class="fc bfc" id="L710" title="All 2 branches covered.">    if (existingDeps != null) {</span>
<span class="fc bfc" id="L711" title="All 2 branches covered.">      existingDeps = autoDependenciesMode == AutoDependenciesMode.OFF</span>
<span class="fc" id="L712">          ? rewriteReferencesToManagedPackages(pkg, environmentRunMode, allPackagesFromFileSets, existingDeps)</span>
<span class="fc" id="L713">          : removeReferencesToManagedPackages(existingDeps, allPackagesFromFileSets);</span>
    }

    Dependency[] deps;
<span class="fc bfc" id="L717" title="All 2 branches covered.">    if (dependencyFile != null) {</span>
<span class="fc" id="L718">      Dependency newDependency = createDependencyFromContentPackageFile(dependencyFile, environmentRunMode);</span>
<span class="fc" id="L719">      deps = addDependency(existingDeps, newDependency);</span>
<span class="fc" id="L720">    }</span>
    else {
<span class="fc" id="L722">      deps = existingDeps;</span>
    }

<span class="fc bfc" id="L725" title="All 2 branches covered.">    if (deps != null) {</span>
<span class="fc" id="L726">      String dependenciesString = Dependency.toString(deps);</span>
<span class="fc" id="L727">      props.put(NAME_DEPENDENCIES, dependenciesString);</span>
    }
<span class="fc" id="L729">  }</span>

  private @NotNull Dependency createDependencyFromContentPackageFile(@NotNull ContentPackageFile dependencyFile,
      @NotNull String environmentRunMode) {
<span class="fc" id="L733">    String runModeSuffix = buildRunModeSuffix(dependencyFile, environmentRunMode);</span>
<span class="fc" id="L734">    String dependencyVersion = dependencyFile.getVersion() + buildVersionSuffix(dependencyFile, true);</span>
<span class="fc" id="L735">    return new Dependency(dependencyFile.getGroup(),</span>
<span class="fc" id="L736">        dependencyFile.getName() + runModeSuffix,</span>
<span class="fc" id="L737">        VersionRange.fromString(dependencyVersion));</span>
  }

  private static Dependency[] addDependency(Dependency[] existingDeps, Dependency newDependency) {
<span class="fc bfc" id="L741" title="All 2 branches covered.">    if (existingDeps != null) {</span>
<span class="fc" id="L742">      return DependencyUtil.add(existingDeps, newDependency);</span>
    }
    else {
<span class="fc" id="L745">      return new Dependency[] { newDependency };</span>
    }
  }

  private static void addSuffixToPackageName(Properties props, ContentPackageFile pkg, String environmentRunMode) {
<span class="fc" id="L750">    String runModeSuffix = buildRunModeSuffix(pkg, environmentRunMode);</span>
<span class="fc" id="L751">    String packageName = props.getProperty(NAME_NAME) + runModeSuffix;</span>
<span class="fc" id="L752">    props.put(NAME_NAME, packageName);</span>
<span class="fc" id="L753">  }</span>

  private void addSuffixToVersion(Properties props, ContentPackageFile pkg) {
    // package version
<span class="pc bpc" id="L757" title="1 of 2 branches missed.">    if (StringUtils.isEmpty(pkg.getVersion())) {</span>
<span class="nc" id="L758">      return;</span>
    }
<span class="fc" id="L760">    String suffixedVersion = pkg.getVersion() + buildVersionSuffix(pkg, true);</span>
<span class="fc" id="L761">    props.put(NAME_VERSION, suffixedVersion);</span>
<span class="fc" id="L762">  }</span>

  private @NotNull Dependency[] rewriteReferencesToManagedPackages(@NotNull ContentPackageFile pkg,
      @NotNull String environmentRunMode, @NotNull Set&lt;Dependency&gt; allPackagesFromFileSets, @NotNull Dependency[] deps) {
<span class="fc" id="L766">    return Arrays.stream(deps)</span>
<span class="fc" id="L767">        .map(dep -&gt; rewriteReferenceIfDependencyIsManagedPackage(pkg, environmentRunMode, allPackagesFromFileSets, dep))</span>
<span class="fc" id="L768">        .toArray(Dependency[]::new);</span>
  }

  private @NotNull Dependency rewriteReferenceIfDependencyIsManagedPackage(@NotNull ContentPackageFile pkg,
      @NotNull String environmentRunMode, @NotNull Set&lt;Dependency&gt; allPackagesFromFileSets, @NotNull Dependency dep) {
    // not a managed package, return as is
<span class="fc bfc" id="L774" title="All 2 branches covered.">    if (!allPackagesFromFileSets.contains(dep)) {</span>
<span class="fc" id="L775">      return dep;</span>
    }
<span class="fc" id="L777">    return findContentPackageFileForDependency(pkg, dep)</span>
        // found a content package file for the dependency, rewrite the dependency
<span class="fc" id="L779">        .map(contentPackageFile -&gt; createDependencyFromContentPackageFile(contentPackageFile, environmentRunMode))</span>
        // found no content package file for the dependency, use current run mode suffix
<span class="fc" id="L781">        .orElseGet(() -&gt; createDependencyWithCurrentPackageRunModeSuffix(pkg, environmentRunMode, dep));</span>
  }

  private @NotNull Optional&lt;ContentPackageFile&gt; findContentPackageFileForDependency(@NotNull ContentPackageFile pkg,
      @NotNull Dependency dep) {
    // look for content package in all file sets
<span class="fc" id="L787">    return contentPackageFileSets.stream()</span>
            // prefer file set which contains the current package to use current run mode
<span class="fc" id="L789">            .sorted((fileSet1, fileSet2) -&gt; sortFileSetsContainingPackageFirst(pkg, fileSet1, fileSet2))</span>
<span class="fc" id="L790">            .flatMap(fileSet -&gt; fileSet.getFiles().stream())</span>
<span class="fc" id="L791">            .filter(contentPackageFile -&gt; isContentPackageForDependency(contentPackageFile, dep))</span>
<span class="fc" id="L792">            .findFirst();</span>
  }

  private int sortFileSetsContainingPackageFirst(@NotNull ContentPackageFile pkg,
      @NotNull ContentPackageFileSet fileSet1, @NotNull ContentPackageFileSet fileSet2) {
<span class="fc bfc" id="L797" title="All 2 branches covered.">    int fileSet1ContainsPackage = fileSet1.getFiles().contains(pkg) ? 1 : 0;</span>
<span class="fc bfc" id="L798" title="All 2 branches covered.">    int fileSet2ContainsPackage = fileSet2.getFiles().contains(pkg) ? 1 : 0;</span>
<span class="fc" id="L799">    return fileSet2ContainsPackage - fileSet1ContainsPackage;</span>
  }

  private boolean isContentPackageForDependency(@NotNull ContentPackageFile contentPackageFile, @NotNull Dependency dep) {
<span class="fc bfc" id="L803" title="All 2 branches covered.">    return contentPackageFile.getGroup().equals(dep.getGroup())</span>
<span class="fc bfc" id="L804" title="All 2 branches covered.">            &amp;&amp; contentPackageFile.getName().equals(dep.getName());</span>
  }

  private @NotNull Dependency createDependencyWithCurrentPackageRunModeSuffix(@NotNull ContentPackageFile pkg,
      @NotNull String environmentRunMode, @NotNull Dependency dep) {
<span class="fc" id="L809">    String runModeSuffix = buildRunModeSuffix(pkg, environmentRunMode);</span>
<span class="fc" id="L810">    return new Dependency(dep.getGroup(), dep.getName() + runModeSuffix, dep.getRange());</span>
  }

  /**
   * Removes existing references to packages contained in the list of packages to manage by this builder because
   * they are added new (and probably with a different package name) during processing.
   * @param deps Dependencies list
   * @param allPackagesFromFileSets Set with all packages from all file sets as dependency instances
   * @return Dependencies list
   */
  private static Dependency[] removeReferencesToManagedPackages(Dependency[] deps, Set&lt;Dependency&gt; allPackagesFromFileSets) {
<span class="fc" id="L821">    return Arrays.stream(deps)</span>
<span class="fc bfc" id="L822" title="All 2 branches covered.">        .filter(dep -&gt; !allPackagesFromFileSets.contains(dep))</span>
<span class="fc" id="L823">        .toArray(size -&gt; new Dependency[size]);</span>
  }

  private static void addDependencyInformation(Set&lt;Dependency&gt; allPackagesFromFileSets, ContentPackageFile pkg) {
<span class="fc" id="L827">    allPackagesFromFileSets.add(new Dependency(pkg.getGroup(), pkg.getName(), VersionRange.fromString(pkg.getVersion())));</span>
<span class="fc" id="L828">  }</span>

  /**
   * @return Group name
   */
  public String getGroupName() {
<span class="nc" id="L834">    return this.groupName;</span>
  }

  /**
   * @return Package name
   */
  public String getPackageName() {
<span class="nc" id="L841">    return this.packageName;</span>
  }

  /**
   * @return Target file
   */
  public File getTargetFile() {
<span class="fc" id="L848">    return this.targetFile;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>